{"/home/travis/build/npmtest/node-npmtest-stylus/test.js":"/* istanbul instrument in package npmtest_stylus */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-stylus/lib.npmtest_stylus.js":"/* istanbul instrument in package npmtest_stylus */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_stylus = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_stylus = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-stylus/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-stylus && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_stylus */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_stylus\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_stylus.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_stylus.rollup.js'] =\n            local.assetsDict['/assets.npmtest_stylus.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_stylus.__dirname +\n                    '/lib.npmtest_stylus.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/index.js":"\nmodule.exports = process.env.STYLUS_COV\n  ? require('./lib-cov/stylus')\n  : require('./lib/stylus');","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/stylus.js":"/*!\n * Stylus\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Renderer = require('./renderer')\n  , nodes = require('./nodes')\n  , utils = require('./utils');\n\n/**\n * Export render as the module.\n */\n\nexports = module.exports = render;\n\n/**\n * Library version.\n */\n\nexports.version = require('../package').version;\n\n/**\n * Expose nodes.\n */\n\nexports.nodes = nodes;\n\n/**\n * Expose BIFs.\n */\n\nexports.functions = require('./functions');\n\n/**\n * Expose utils.\n */\n\nexports.utils = require('./utils');\n\n/**\n * Expose middleware.\n */\n\nexports.middleware = require('./middleware');\n\n/**\n * Expose constructors.\n */\n\nexports.Visitor = require('./visitor');\nexports.Parser = require('./parser');\nexports.Evaluator = require('./visitor/evaluator');\nexports.Normalizer = require('./visitor/normalizer');\nexports.Compiler = require('./visitor/compiler');\n\n/**\n * Convert the given `css` to `stylus` source.\n *\n * @param {String} css\n * @return {String}\n * @api public\n */\n\nexports.convertCSS = require('./convert/css');\n\n/**\n * Render the given `str` with `options` and callback `fn(err, css)`.\n *\n * @param {String} str\n * @param {Object|Function} options\n * @param {Function} fn\n * @api public\n */\n\nexports.render = function(str, options, fn){\n  if ('function' == typeof options) fn = options, options = {};\n  return new Renderer(str, options).render(fn);\n};\n\n/**\n * Return a new `Renderer` for the given `str` and `options`.\n *\n * @param {String} str\n * @param {Object} options\n * @return {Renderer}\n * @api public\n */\n\nfunction render(str, options) {\n  return new Renderer(str, options);\n}\n\n/**\n * Expose optional functions.\n */\n\nexports.url = require('./functions/url');\nexports.resolver = require('./functions/resolver');\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/renderer.js":"\n/*!\n * Stylus - Renderer\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Parser = require('./parser')\n  , EventEmitter = require('events').EventEmitter\n  , Evaluator = require('./visitor/evaluator')\n  , Normalizer = require('./visitor/normalizer')\n  , events = new EventEmitter\n  , utils = require('./utils')\n  , nodes = require('./nodes')\n  , join = require('path').join;\n\n/**\n * Expose `Renderer`.\n */\n\nmodule.exports = Renderer;\n\n/**\n * Initialize a new `Renderer` with the given `str` and `options`.\n *\n * @param {String} str\n * @param {Object} options\n * @api public\n */\n\nfunction Renderer(str, options) {\n  options = options || {};\n  options.globals = options.globals || {};\n  options.functions = options.functions || {};\n  options.use = options.use || [];\n  options.use = Array.isArray(options.use) ? options.use : [options.use];\n  options.imports = [join(__dirname, 'functions')];\n  options.paths = options.paths || [];\n  options.filename = options.filename || 'stylus';\n  options.Evaluator = options.Evaluator || Evaluator;\n  this.options = options;\n  this.str = str;\n  this.events = events;\n};\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\n\nRenderer.prototype.__proto__ = EventEmitter.prototype;\n\n/**\n * Expose events explicitly.\n */\n\nmodule.exports.events = events;\n\n/**\n * Parse and evaluate AST, then callback `fn(err, css, js)`.\n *\n * @param {Function} fn\n * @api public\n */\n\nRenderer.prototype.render = function(fn){\n  var parser = this.parser = new Parser(this.str, this.options);\n\n  // use plugin(s)\n  for (var i = 0, len = this.options.use.length; i < len; i++) {\n    this.use(this.options.use[i]);\n  }\n\n  try {\n    nodes.filename = this.options.filename;\n    // parse\n    var ast = parser.parse();\n\n    // evaluate\n    this.evaluator = new this.options.Evaluator(ast, this.options);\n    this.nodes = nodes;\n    this.evaluator.renderer = this;\n    ast = this.evaluator.evaluate();\n\n    // normalize\n    var normalizer = new Normalizer(ast, this.options);\n    ast = normalizer.normalize();\n\n    // compile\n    var compiler = this.options.sourcemap\n      ? new (require('./visitor/sourcemapper'))(ast, this.options)\n      : new (require('./visitor/compiler'))(ast, this.options)\n      , css = compiler.compile();\n\n    // expose sourcemap\n    if (this.options.sourcemap) this.sourcemap = compiler.map.toJSON();\n  } catch (err) {\n    var options = {};\n    options.input = err.input || this.str;\n    options.filename = err.filename || this.options.filename;\n    options.lineno = err.lineno || parser.lexer.lineno;\n    options.column = err.column || parser.lexer.column;\n    if (!fn) throw utils.formatException(err, options);\n    return fn(utils.formatException(err, options));\n  }\n\n  // fire `end` event\n  var listeners = this.listeners('end');\n  if (fn) listeners.push(fn);\n  for (var i = 0, len = listeners.length; i < len; i++) {\n    var ret = listeners[i](null, css);\n    if (ret) css = ret;\n  }\n  if (!fn) return css;\n};\n\n/**\n * Get dependencies of the compiled file.\n *\n * @param {String} [filename]\n * @return {Array}\n * @api public\n */\n\nRenderer.prototype.deps = function(filename){\n  var opts = utils.merge({ cache: false }, this.options);\n  if (filename) opts.filename = filename;\n\n  var DepsResolver = require('./visitor/deps-resolver')\n    , parser = new Parser(this.str, opts);\n\n  try {\n    nodes.filename = opts.filename;\n    // parse\n    var ast = parser.parse()\n      , resolver = new DepsResolver(ast, opts);\n\n    // resolve dependencies\n    return resolver.resolve();\n  } catch (err) {\n    var options = {};\n    options.input = err.input || this.str;\n    options.filename = err.filename || opts.filename;\n    options.lineno = err.lineno || parser.lexer.lineno;\n    options.column = err.column || parser.lexer.column;\n    throw utils.formatException(err, options);\n  }\n};\n\n/**\n * Set option `key` to `val`.\n *\n * @param {String} key\n * @param {Mixed} val\n * @return {Renderer} for chaining\n * @api public\n */\n\nRenderer.prototype.set = function(key, val){\n  this.options[key] = val;\n  return this;\n};\n\n/**\n * Get option `key`.\n *\n * @param {String} key\n * @return {Mixed} val\n * @api public\n */\n\nRenderer.prototype.get = function(key){\n  return this.options[key];\n};\n\n/**\n * Include the given `path` to the lookup paths array.\n *\n * @param {String} path\n * @return {Renderer} for chaining\n * @api public\n */\n\nRenderer.prototype.include = function(path){\n  this.options.paths.push(path);\n  return this;\n};\n\n/**\n * Use the given `fn`.\n *\n * This allows for plugins to alter the renderer in\n * any way they wish, exposing paths etc.\n *\n * @param {Function}\n * @return {Renderer} for chaining\n * @api public\n */\n\nRenderer.prototype.use = function(fn){\n  fn.call(this, this);\n  return this;\n};\n\n/**\n * Define function or global var with the given `name`. Optionally\n * the function may accept full expressions, by setting `raw`\n * to `true`.\n *\n * @param {String} name\n * @param {Function|Node} fn\n * @return {Renderer} for chaining\n * @api public\n */\n\nRenderer.prototype.define = function(name, fn, raw){\n  fn = utils.coerce(fn, raw);\n\n  if (fn.nodeName) {\n    this.options.globals[name] = fn;\n    return this;\n  }\n\n  // function\n  this.options.functions[name] = fn;\n  if (undefined != raw) fn.raw = raw;\n  return this;\n};\n\n/**\n * Import the given `file`.\n *\n * @param {String} file\n * @return {Renderer} for chaining\n * @api public\n */\n\nRenderer.prototype.import = function(file){\n  this.options.imports.push(file);\n  return this;\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/parser.js":"/*!\n * Stylus - Parser\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Lexer = require('./lexer')\n  , nodes = require('./nodes')\n  , Token = require('./token')\n  , units = require('./units')\n  , errors = require('./errors')\n  , cache = require('./cache');\n\n// debuggers\n\nvar debug = {\n    lexer: require('debug')('stylus:lexer')\n  , selector: require('debug')('stylus:parser:selector')\n};\n\n/**\n * Selector composite tokens.\n */\n\nvar selectorTokens = [\n    'ident'\n  , 'string'\n  , 'selector'\n  , 'function'\n  , 'comment'\n  , 'boolean'\n  , 'space'\n  , 'color'\n  , 'unit'\n  , 'for'\n  , 'in'\n  , '['\n  , ']'\n  , '('\n  , ')'\n  , '+'\n  , '-'\n  , '*'\n  , '*='\n  , '<'\n  , '>'\n  , '='\n  , ':'\n  , '&'\n  , '&&'\n  , '~'\n  , '{'\n  , '}'\n  , '.'\n  , '..'\n  , '/'\n];\n\n/**\n * CSS pseudo-classes and pseudo-elements.\n * See http://dev.w3.org/csswg/selectors4/\n */\n\nvar pseudoSelectors = [\n  // Logical Combinations\n    'matches'\n  , 'not'\n\n  // Linguistic Pseudo-classes\n  , 'dir'\n  , 'lang'\n\n  // Location Pseudo-classes\n  , 'any-link'\n  , 'link'\n  , 'visited'\n  , 'local-link'\n  , 'target'\n  , 'scope'\n\n  // User Action Pseudo-classes\n  , 'hover'\n  , 'active'\n  , 'focus'\n  , 'drop'\n\n  // Time-dimensional Pseudo-classes\n  , 'current'\n  , 'past'\n  , 'future'\n\n  // The Input Pseudo-classes\n  , 'enabled'\n  , 'disabled'\n  , 'read-only'\n  , 'read-write'\n  , 'placeholder-shown'\n  , 'checked'\n  , 'indeterminate'\n  , 'valid'\n  , 'invalid'\n  , 'in-range'\n  , 'out-of-range'\n  , 'required'\n  , 'optional'\n  , 'user-error'\n\n  // Tree-Structural pseudo-classes\n  , 'root'\n  , 'empty'\n  , 'blank'\n  , 'nth-child'\n  , 'nth-last-child'\n  , 'first-child'\n  , 'last-child'\n  , 'only-child'\n  , 'nth-of-type'\n  , 'nth-last-of-type'\n  , 'first-of-type'\n  , 'last-of-type'\n  , 'only-of-type'\n  , 'nth-match'\n  , 'nth-last-match'\n\n  // Grid-Structural Selectors\n  , 'nth-column'\n  , 'nth-last-column'\n\n  // Pseudo-elements\n  , 'first-line'\n  , 'first-letter'\n  , 'before'\n  , 'after'\n\n  // Non-standard\n  , 'selection'\n];\n\n/**\n * Initialize a new `Parser` with the given `str` and `options`.\n *\n * @param {String} str\n * @param {Object} options\n * @api private\n */\n\nvar Parser = module.exports = function Parser(str, options) {\n  var self = this;\n  options = options || {};\n  Parser.cache = Parser.cache || Parser.getCache(options);\n  this.hash = Parser.cache.key(str, options);\n  this.lexer = {};\n  if (!Parser.cache.has(this.hash)) {\n    this.lexer = new Lexer(str, options);\n  }\n  this.prefix = options.prefix || '';\n  this.root = options.root || new nodes.Root;\n  this.state = ['root'];\n  this.stash = [];\n  this.parens = 0;\n  this.css = 0;\n  this.state.pop = function(){\n    self.prevState = [].pop.call(this);\n  };\n};\n\n/**\n * Get cache instance.\n *\n * @param {Object} options\n * @return {Object}\n * @api private\n */\n\nParser.getCache = function(options) {\n  return false === options.cache\n    ? cache(false)\n    : cache(options.cache || 'memory', options);\n};\n\n/**\n * Parser prototype.\n */\n\nParser.prototype = {\n\n  /**\n   * Constructor.\n   */\n\n  constructor: Parser,\n\n  /**\n   * Return current state.\n   *\n   * @return {String}\n   * @api private\n   */\n\n  currentState: function() {\n    return this.state[this.state.length - 1];\n  },\n\n  /**\n   * Return previous state.\n   *\n   * @return {String}\n   * @api private\n   */\n\n  previousState: function() {\n    return this.state[this.state.length - 2];\n  },\n\n  /**\n   * Parse the input, then return the root node.\n   *\n   * @return {Node}\n   * @api private\n   */\n\n  parse: function(){\n    var block = this.parent = this.root;\n    if (Parser.cache.has(this.hash)) {\n      block = Parser.cache.get(this.hash);\n      // normalize cached imports\n      if ('block' == block.nodeName) block.constructor = nodes.Root;\n    } else {\n      while ('eos' != this.peek().type) {\n        this.skipWhitespace();\n        if ('eos' == this.peek().type) break;\n        var stmt = this.statement();\n        this.accept(';');\n        if (!stmt) this.error('unexpected token {peek}, not allowed at the root level');\n        block.push(stmt);\n      }\n      Parser.cache.set(this.hash, block);\n    }\n    return block;\n  },\n\n  /**\n   * Throw an `Error` with the given `msg`.\n   *\n   * @param {String} msg\n   * @api private\n   */\n\n  error: function(msg){\n    var type = this.peek().type\n      , val = undefined == this.peek().val\n        ? ''\n        : ' ' + this.peek().toString();\n    if (val.trim() == type.trim()) val = '';\n    throw new errors.ParseError(msg.replace('{peek}', '\"' + type + val + '\"'));\n  },\n\n  /**\n   * Accept the given token `type`, and return it,\n   * otherwise return `undefined`.\n   *\n   * @param {String} type\n   * @return {Token}\n   * @api private\n   */\n\n  accept: function(type){\n    if (type == this.peek().type) {\n      return this.next();\n    }\n  },\n\n  /**\n   * Expect token `type` and return it, throw otherwise.\n   *\n   * @param {String} type\n   * @return {Token}\n   * @api private\n   */\n\n  expect: function(type){\n    if (type != this.peek().type) {\n      this.error('expected \"' + type + '\", got {peek}');\n    }\n    return this.next();\n  },\n\n  /**\n   * Get the next token.\n   *\n   * @return {Token}\n   * @api private\n   */\n\n  next: function() {\n    var tok = this.stash.length\n      ? this.stash.pop()\n      : this.lexer.next()\n      , line = tok.lineno\n      , column = tok.column || 1;\n\n    if (tok.val && tok.val.nodeName) {\n      tok.val.lineno = line;\n      tok.val.column = column;\n    }\n    nodes.lineno = line;\n    nodes.column = column;\n    debug.lexer('%s %s', tok.type, tok.val || '');\n    return tok;\n  },\n\n  /**\n   * Peek with lookahead(1).\n   *\n   * @return {Token}\n   * @api private\n   */\n\n  peek: function() {\n    return this.lexer.peek();\n  },\n\n  /**\n   * Lookahead `n` tokens.\n   *\n   * @param {Number} n\n   * @return {Token}\n   * @api private\n   */\n\n  lookahead: function(n){\n    return this.lexer.lookahead(n);\n  },\n\n  /**\n   * Check if the token at `n` is a valid selector token.\n   *\n   * @param {Number} n\n   * @return {Boolean}\n   * @api private\n   */\n\n  isSelectorToken: function(n) {\n    var la = this.lookahead(n).type;\n    switch (la) {\n      case 'for':\n        return this.bracketed;\n      case '[':\n        this.bracketed = true;\n        return true;\n      case ']':\n        this.bracketed = false;\n        return true;\n      default:\n        return ~selectorTokens.indexOf(la);\n    }\n  },\n\n  /**\n   * Check if the token at `n` is a pseudo selector.\n   *\n   * @param {Number} n\n   * @return {Boolean}\n   * @api private\n   */\n\n  isPseudoSelector: function(n){\n    var val = this.lookahead(n).val;\n    return val && ~pseudoSelectors.indexOf(val.name);\n  },\n\n  /**\n   * Check if the current line contains `type`.\n   *\n   * @param {String} type\n   * @return {Boolean}\n   * @api private\n   */\n\n  lineContains: function(type){\n    var i = 1\n      , la;\n\n    while (la = this.lookahead(i++)) {\n      if (~['indent', 'outdent', 'newline', 'eos'].indexOf(la.type)) return;\n      if (type == la.type) return true;\n    }\n  },\n\n  /**\n   * Valid selector tokens.\n   */\n\n  selectorToken: function() {\n    if (this.isSelectorToken(1)) {\n      if ('{' == this.peek().type) {\n        // unclosed, must be a block\n        if (!this.lineContains('}')) return;\n        // check if ':' is within the braces.\n        // though not required by Stylus, chances\n        // are if someone is using {} they will\n        // use CSS-style props, helping us with\n        // the ambiguity in this case\n        var i = 0\n          , la;\n        while (la = this.lookahead(++i)) {\n          if ('}' == la.type) {\n            // Check empty block.\n            if (i == 2 || (i == 3 && this.lookahead(i - 1).type == 'space'))\n              return;\n            break;\n          }\n          if (':' == la.type) return;\n        }\n      }\n      return this.next();\n    }\n  },\n\n  /**\n   * Skip the given `tokens`.\n   *\n   * @param {Array} tokens\n   * @api private\n   */\n\n  skip: function(tokens) {\n    while (~tokens.indexOf(this.peek().type))\n      this.next();\n  },\n\n  /**\n   * Consume whitespace.\n   */\n\n  skipWhitespace: function() {\n    this.skip(['space', 'indent', 'outdent', 'newline']);\n  },\n\n  /**\n   * Consume newlines.\n   */\n\n  skipNewlines: function() {\n    while ('newline' == this.peek().type)\n      this.next();\n  },\n\n  /**\n   * Consume spaces.\n   */\n\n  skipSpaces: function() {\n    while ('space' == this.peek().type)\n      this.next();\n  },\n\n  /**\n   * Consume spaces and comments.\n   */\n\n  skipSpacesAndComments: function() {\n    while ('space' == this.peek().type\n      || 'comment' == this.peek().type)\n      this.next();\n  },\n\n  /**\n   * Check if the following sequence of tokens\n   * forms a function definition, ie trailing\n   * `{` or indentation.\n   */\n\n  looksLikeFunctionDefinition: function(i) {\n    return 'indent' == this.lookahead(i).type\n      || '{' == this.lookahead(i).type;\n  },\n\n  /**\n   * Check if the following sequence of tokens\n   * forms a selector.\n   *\n   * @param {Boolean} [fromProperty]\n   * @return {Boolean}\n   * @api private\n   */\n\n  looksLikeSelector: function(fromProperty) {\n    var i = 1\n      , brace;\n\n    // Real property\n    if (fromProperty && ':' == this.lookahead(i + 1).type\n      && (this.lookahead(i + 1).space || 'indent' == this.lookahead(i + 2).type))\n      return false;\n\n    // Assume selector when an ident is\n    // followed by a selector\n    while ('ident' == this.lookahead(i).type\n      && ('newline' == this.lookahead(i + 1).type\n         || ',' == this.lookahead(i + 1).type)) i += 2;\n\n    while (this.isSelectorToken(i)\n      || ',' == this.lookahead(i).type) {\n\n      if ('selector' == this.lookahead(i).type)\n        return true;\n\n      if ('&' == this.lookahead(i + 1).type)\n        return true;\n\n      if ('.' == this.lookahead(i).type && 'ident' == this.lookahead(i + 1).type)\n        return true;\n\n      if ('*' == this.lookahead(i).type && 'newline' == this.lookahead(i + 1).type)\n        return true;\n\n      // Pseudo-elements\n      if (':' == this.lookahead(i).type\n        && ':' == this.lookahead(i + 1).type)\n        return true; \n\n      // #a after an ident and newline\n      if ('color' == this.lookahead(i).type\n        && 'newline' == this.lookahead(i - 1).type)\n        return true;\n\n      if (this.looksLikeAttributeSelector(i))\n        return true;\n\n      if (('=' == this.lookahead(i).type || 'function' == this.lookahead(i).type)\n        && '{' == this.lookahead(i + 1).type)\n        return false;\n\n      // Hash values inside properties\n      if (':' == this.lookahead(i).type\n        && !this.isPseudoSelector(i + 1)\n        && this.lineContains('.'))\n        return false;\n\n      // the ':' token within braces signifies\n      // a selector. ex: \"foo{bar:'baz'}\"\n      if ('{' == this.lookahead(i).type) brace = true;\n      else if ('}' == this.lookahead(i).type) brace = false;\n      if (brace && ':' == this.lookahead(i).type) return true;\n\n      // '{' preceded by a space is considered a selector.\n      // for example \"foo{bar}{baz}\" may be a property,\n      // however \"foo{bar} {baz}\" is a selector\n      if ('space' == this.lookahead(i).type\n        && '{' == this.lookahead(i + 1).type)\n        return true;\n\n      // Assume pseudo selectors are NOT properties\n      // as 'td:th-child(1)' may look like a property\n      // and function call to the parser otherwise\n      if (':' == this.lookahead(i++).type\n        && !this.lookahead(i-1).space\n        && this.isPseudoSelector(i))\n        return true;\n\n      // Trailing space\n      if ('space' == this.lookahead(i).type\n        && 'newline' == this.lookahead(i + 1).type\n        && '{' == this.lookahead(i + 2).type)\n        return true;\n\n      if (',' == this.lookahead(i).type\n        && 'newline' == this.lookahead(i + 1).type)\n        return true;\n    }\n\n    // Trailing comma\n    if (',' == this.lookahead(i).type\n      && 'newline' == this.lookahead(i + 1).type)\n      return true;\n\n    // Trailing brace\n    if ('{' == this.lookahead(i).type\n      && 'newline' == this.lookahead(i + 1).type)\n      return true;\n\n    // css-style mode, false on ; }\n    if (this.css) {\n      if (';' == this.lookahead(i).type ||\n          '}' == this.lookahead(i - 1).type)\n        return false;\n    }\n\n    // Trailing separators\n    while (!~[\n        'indent'\n      , 'outdent'\n      , 'newline'\n      , 'for'\n      , 'if'\n      , ';'\n      , '}'\n      , 'eos'].indexOf(this.lookahead(i).type))\n      ++i;\n\n    if ('indent' == this.lookahead(i).type)\n      return true;\n  },\n\n  /**\n   * Check if the following sequence of tokens\n   * forms an attribute selector.\n   */\n\n  looksLikeAttributeSelector: function(n) {\n    var type = this.lookahead(n).type;\n    if ('=' == type && this.bracketed) return true;\n    return ('ident' == type || 'string' == type)\n      && ']' == this.lookahead(n + 1).type\n      && ('newline' == this.lookahead(n + 2).type || this.isSelectorToken(n + 2))\n      && !this.lineContains(':')\n      && !this.lineContains('=');\n  },\n\n  /**\n   * Check if the following sequence of tokens\n   * forms a keyframe block.\n   */\n\n  looksLikeKeyframe: function() {\n    var i = 2\n      , type;\n    switch (this.lookahead(i).type) {\n      case '{':\n      case 'indent':\n      case ',':\n        return true;\n      case 'newline':\n        while ('unit' == this.lookahead(++i).type\n            || 'newline' == this.lookahead(i).type) ;\n        type = this.lookahead(i).type;\n        return 'indent' == type || '{' == type;\n    }\n  },\n\n  /**\n   * Check if the current state supports selectors.\n   */\n\n  stateAllowsSelector: function() {\n    switch (this.currentState()) {\n      case 'root':\n      case 'atblock':\n      case 'selector':\n      case 'conditional':\n      case 'function':\n      case 'atrule':\n      case 'for':\n        return true;\n    }\n  },\n\n  /**\n   * Try to assign @block to the node.\n   *\n   * @param {Expression} expr\n   * @private\n   */\n\n  assignAtblock: function(expr) {\n    try {\n      expr.push(this.atblock(expr));\n    } catch(err) {\n      this.error('invalid right-hand side operand in assignment, got {peek}');\n    }\n  },\n\n  /**\n   *   statement\n   * | statement 'if' expression\n   * | statement 'unless' expression\n   */\n\n  statement: function() {\n    var stmt = this.stmt()\n      , state = this.prevState\n      , block\n      , op;\n\n    // special-case statements since it\n    // is not an expression. We could\n    // implement postfix conditionals at\n    // the expression level, however they\n    // would then fail to enclose properties\n    if (this.allowPostfix) {\n      this.allowPostfix = false;\n      state = 'expression';\n    }\n\n    switch (state) {\n      case 'assignment':\n      case 'expression':\n      case 'function arguments':\n        while (op =\n             this.accept('if')\n          || this.accept('unless')\n          || this.accept('for')) {\n          switch (op.type) {\n            case 'if':\n            case 'unless':\n              stmt = new nodes.If(this.expression(), stmt);\n              stmt.postfix = true;\n              stmt.negate = 'unless' == op.type;\n              this.accept(';');\n              break;\n            case 'for':\n              var key\n                , val = this.id().name;\n              if (this.accept(',')) key = this.id().name;\n              this.expect('in');\n              var each = new nodes.Each(val, key, this.expression());\n              block = new nodes.Block(this.parent, each);\n              block.push(stmt);\n              each.block = block;\n              stmt = each;\n          }\n        }\n    }\n\n    return stmt;\n  },\n\n  /**\n   *    ident\n   *  | selector\n   *  | literal\n   *  | charset\n   *  | namespace\n   *  | import\n   *  | require\n   *  | media\n   *  | atrule\n   *  | scope\n   *  | keyframes\n   *  | mozdocument\n   *  | for\n   *  | if\n   *  | unless\n   *  | comment\n   *  | expression\n   *  | 'return' expression\n   */\n\n  stmt: function() {\n    var type = this.peek().type;\n    switch (type) {\n      case 'keyframes':\n        return this.keyframes();\n      case '-moz-document':\n        return this.mozdocument();\n      case 'comment':\n      case 'selector':\n      case 'literal':\n      case 'charset':\n      case 'namespace':\n      case 'import':\n      case 'require':\n      case 'extend':\n      case 'media':\n      case 'atrule':\n      case 'ident':\n      case 'scope':\n      case 'supports':\n      case 'unless':\n      case 'function':\n      case 'for':\n      case 'if':\n        return this[type]();\n      case 'return':\n        return this.return();\n      case '{':\n        return this.property();\n      default:\n        // Contextual selectors\n        if (this.stateAllowsSelector()) {\n          switch (type) {\n            case 'color':\n            case '~':\n            case '>':\n            case '<':\n            case ':':\n            case '&':\n            case '&&':\n            case '[':\n            case '.':\n            case '/':\n              return this.selector();\n            // relative reference\n            case '..':\n              if ('/' == this.lookahead(2).type)\n                return this.selector();\n            case '+':\n              return 'function' == this.lookahead(2).type\n                ? this.functionCall()\n                : this.selector();\n            case '*':\n              return this.property();\n            // keyframe blocks (10%, 20% { ... })\n            case 'unit':\n              if (this.looksLikeKeyframe()) return this.selector();\n            case '-':\n              if ('{' == this.lookahead(2).type)\n                return this.property();\n          }\n        }\n\n        // Expression fallback\n        var expr = this.expression();\n        if (expr.isEmpty) this.error('unexpected {peek}');\n        return expr;\n    }\n  },\n\n  /**\n   * indent (!outdent)+ outdent\n   */\n\n  block: function(node, scope) {\n    var delim\n      , stmt\n      , next\n      , block = this.parent = new nodes.Block(this.parent, node);\n\n    if (false === scope) block.scope = false;\n\n    this.accept('newline');\n\n    // css-style\n    if (this.accept('{')) {\n      this.css++;\n      delim = '}';\n      this.skipWhitespace();\n    } else {\n      delim = 'outdent';\n      this.expect('indent');\n    }\n\n    while (delim != this.peek().type) {\n      // css-style\n      if (this.css) {\n        if (this.accept('newline') || this.accept('indent')) continue;\n        stmt = this.statement();\n        this.accept(';');\n        this.skipWhitespace();\n      } else {\n        if (this.accept('newline')) continue;\n        // skip useless indents and comments\n        next = this.lookahead(2).type;\n        if ('indent' == this.peek().type\n          && ~['outdent', 'newline', 'comment'].indexOf(next)) {\n          this.skip(['indent', 'outdent']);\n          continue;\n        }\n        if ('eos' == this.peek().type) return block;\n        stmt = this.statement();\n        this.accept(';');\n      }\n      if (!stmt) this.error('unexpected token {peek} in block');\n      block.push(stmt);\n    }\n\n    // css-style\n    if (this.css) {\n      this.skipWhitespace();\n      this.expect('}');\n      this.skipSpaces();\n      this.css--;\n    } else {\n      this.expect('outdent');\n    }\n\n    this.parent = block.parent;\n    return block;\n  },\n\n  /**\n   * comment space*\n   */\n\n  comment: function(){\n    var node = this.next().val;\n    this.skipSpaces();\n    return node;\n  },\n\n  /**\n   * for val (',' key) in expr\n   */\n\n  for: function() {\n    this.expect('for');\n    var key\n      , val = this.id().name;\n    if (this.accept(',')) key = this.id().name;\n    this.expect('in');\n    this.state.push('for');\n    this.cond = true;\n    var each = new nodes.Each(val, key, this.expression());\n    this.cond = false;\n    each.block = this.block(each, false);\n    this.state.pop();\n    return each;\n  },\n\n  /**\n   * return expression\n   */\n\n  return: function() {\n    this.expect('return');\n    var expr = this.expression();\n    return expr.isEmpty\n      ? new nodes.Return\n      : new nodes.Return(expr);\n  },\n\n  /**\n   * unless expression block\n   */\n\n  unless: function() {\n    this.expect('unless');\n    this.state.push('conditional');\n    this.cond = true;\n    var node = new nodes.If(this.expression(), true);\n    this.cond = false;\n    node.block = this.block(node, false);\n    this.state.pop();\n    return node;\n  },\n\n  /**\n   * if expression block (else block)?\n   */\n\n  if: function() {\n    this.expect('if');\n    this.state.push('conditional');\n    this.cond = true;\n    var node = new nodes.If(this.expression())\n      , cond\n      , block;\n    this.cond = false;\n    node.block = this.block(node, false);\n    this.skip(['newline', 'comment']);\n    while (this.accept('else')) {\n      if (this.accept('if')) {\n        this.cond = true;\n        cond = this.expression();\n        this.cond = false;\n        block = this.block(node, false);\n        node.elses.push(new nodes.If(cond, block));\n      } else {\n        node.elses.push(this.block(node, false));\n        break;\n      }\n      this.skip(['newline', 'comment']);\n    }\n    this.state.pop();\n    return node;\n  },\n\n  /**\n   * @block\n   *\n   * @param {Expression} [node]\n   */\n\n  atblock: function(node){\n    if (!node) this.expect('atblock');\n    node = new nodes.Atblock;\n    this.state.push('atblock');\n    node.block = this.block(node, false);\n    this.state.pop();\n    return node;\n  },\n\n  /**\n   * atrule selector? block?\n   */\n\n  atrule: function(){\n    var type = this.expect('atrule').val\n      , node = new nodes.Atrule(type)\n      , tok;\n    this.skipSpacesAndComments();\n    node.segments = this.selectorParts();\n    this.skipSpacesAndComments();\n    tok = this.peek().type;\n    if ('indent' == tok || '{' == tok || ('newline' == tok\n      && '{' == this.lookahead(2).type)) {\n      this.state.push('atrule');\n      node.block = this.block(node);\n      this.state.pop();\n    }\n    return node;\n  },\n\n  /**\n   * scope\n   */\n\n  scope: function(){\n    this.expect('scope');\n    var selector = this.selectorParts()\n      .map(function(selector) { return selector.val; })\n      .join('');\n    this.selectorScope = selector.trim();\n    return nodes.null;\n  },\n\n  /**\n   * supports\n   */\n\n  supports: function(){\n    this.expect('supports');\n    var node = new nodes.Supports(this.supportsCondition());\n    this.state.push('atrule');\n    node.block = this.block(node);\n    this.state.pop();\n    return node;\n  },\n\n  /**\n   *   supports negation\n   * | supports op\n   * | expression\n   */\n\n  supportsCondition: function(){\n    var node = this.supportsNegation()\n      || this.supportsOp();\n    if (!node) {\n      this.cond = true;\n      node = this.expression();\n      this.cond = false;\n    }\n    return node;\n  },\n\n  /**\n   * 'not' supports feature\n   */\n\n  supportsNegation: function(){\n    if (this.accept('not')) {\n      var node = new nodes.Expression;\n      node.push(new nodes.Literal('not'));\n      node.push(this.supportsFeature());\n      return node;\n    }\n  },\n\n  /**\n   * supports feature (('and' | 'or') supports feature)+\n   */\n\n  supportsOp: function(){\n    var feature = this.supportsFeature()\n      , op\n      , expr;\n    if (feature) {\n      expr = new nodes.Expression;\n      expr.push(feature);\n      while (op = this.accept('&&') || this.accept('||')) {\n        expr.push(new nodes.Literal('&&' == op.val ? 'and' : 'or'));\n        expr.push(this.supportsFeature());\n      }\n      return expr;\n    }\n  },\n\n  /**\n   *   ('(' supports condition ')')\n   * | feature\n   */\n\n  supportsFeature: function(){\n    this.skipSpacesAndComments();\n    if ('(' == this.peek().type) {\n      var la = this.lookahead(2).type;\n\n      if ('ident' == la || '{' == la) {\n        return this.feature();\n      } else {\n        this.expect('(');\n        var node = new nodes.Expression;\n        node.push(new nodes.Literal('('));\n        node.push(this.supportsCondition());\n        this.expect(')')\n        node.push(new nodes.Literal(')'));\n        this.skipSpacesAndComments();\n        return node;\n      }\n    }\n  },\n\n  /**\n   * extend\n   */\n\n  extend: function(){\n    var tok = this.expect('extend')\n      , selectors = []\n      , sel\n      , node\n      , arr;\n\n    do {\n      arr = this.selectorParts();\n\n      if (!arr.length) continue;\n\n      sel = new nodes.Selector(arr);\n      selectors.push(sel);\n\n      if ('!' !== this.peek().type) continue;\n\n      tok = this.lookahead(2);\n      if ('ident' !== tok.type || 'optional' !== tok.val.name) continue;\n\n      this.skip(['!', 'ident']);\n      sel.optional = true;\n    } while(this.accept(','));\n\n    node = new nodes.Extend(selectors);\n    node.lineno = tok.lineno;\n    node.column = tok.column;\n    return node;\n  },\n\n  /**\n   * media queries\n   */\n\n  media: function() {\n    this.expect('media');\n    this.state.push('atrule');\n    var media = new nodes.Media(this.queries());\n    media.block = this.block(media);\n    this.state.pop();\n    return media;\n  },\n\n  /**\n   * query (',' query)*\n   */\n\n  queries: function() {\n    var queries = new nodes.QueryList\n      , skip = ['comment', 'newline', 'space'];\n\n    do {\n      this.skip(skip);\n      queries.push(this.query());\n      this.skip(skip);\n    } while (this.accept(','));\n    return queries;\n  },\n\n  /**\n   *   expression\n   * | (ident | 'not')? ident ('and' feature)*\n   * | feature ('and' feature)*\n   */\n\n  query: function() {\n    var query = new nodes.Query\n      , expr\n      , pred\n      , id;\n\n    // hash values support\n    if ('ident' == this.peek().type\n      && ('.' == this.lookahead(2).type\n      || '[' == this.lookahead(2).type)) {\n      this.cond = true;\n      expr = this.expression();\n      this.cond = false;\n      query.push(new nodes.Feature(expr.nodes));\n      return query;\n    }\n\n    if (pred = this.accept('ident') || this.accept('not')) {\n      pred = new nodes.Literal(pred.val.string || pred.val);\n\n      this.skipSpacesAndComments();\n      if (id = this.accept('ident')) {\n        query.type = id.val;\n        query.predicate = pred;\n      } else {\n        query.type = pred;\n      }\n      this.skipSpacesAndComments();\n\n      if (!this.accept('&&')) return query;\n    }\n\n    do {\n      query.push(this.feature());\n    } while (this.accept('&&'));\n\n    return query;\n  },\n\n  /**\n   * '(' ident ( ':'? expression )? ')'\n   */\n\n  feature: function() {\n    this.skipSpacesAndComments();\n    this.expect('(');\n    this.skipSpacesAndComments();\n    var node = new nodes.Feature(this.interpolate());\n    this.skipSpacesAndComments();\n    this.accept(':')\n    this.skipSpacesAndComments();\n    this.inProperty = true;\n    node.expr = this.list();\n    this.inProperty = false;\n    this.skipSpacesAndComments();\n    this.expect(')');\n    this.skipSpacesAndComments();\n    return node;\n  },\n\n  /**\n   * @-moz-document call (',' call)* block\n   */\n\n  mozdocument: function(){\n    this.expect('-moz-document');\n    var mozdocument = new nodes.Atrule('-moz-document')\n      , calls = [];\n    do {\n      this.skipSpacesAndComments();\n      calls.push(this.functionCall());\n      this.skipSpacesAndComments();\n    } while (this.accept(','));\n    mozdocument.segments = [new nodes.Literal(calls.join(', '))];\n    this.state.push('atrule');\n    mozdocument.block = this.block(mozdocument, false);\n    this.state.pop();\n    return mozdocument;\n  },\n\n  /**\n   * import expression\n   */\n\n  import: function() {\n    this.expect('import');\n    this.allowPostfix = true;\n    return new nodes.Import(this.expression(), false);\n  },\n\n  /**\n   * require expression\n   */\n\n  require: function() {\n    this.expect('require');\n    this.allowPostfix = true;\n    return new nodes.Import(this.expression(), true);\n  },\n\n  /**\n   * charset string\n   */\n\n  charset: function() {\n    this.expect('charset');\n    var str = this.expect('string').val;\n    this.allowPostfix = true;\n    return new nodes.Charset(str);\n  },\n\n  /**\n   * namespace ident? (string | url)\n   */\n\n  namespace: function() {\n    var str\n      , prefix;\n    this.expect('namespace');\n\n    this.skipSpacesAndComments();\n    if (prefix = this.accept('ident')) {\n      prefix = prefix.val;\n    }\n    this.skipSpacesAndComments();\n\n    str = this.accept('string') || this.url();\n    this.allowPostfix = true;\n    return new nodes.Namespace(str, prefix);\n  },\n\n  /**\n   * keyframes name block\n   */\n\n  keyframes: function() {\n    var tok = this.expect('keyframes')\n      , keyframes;\n\n    this.skipSpacesAndComments();\n    keyframes = new nodes.Keyframes(this.selectorParts(), tok.val);\n    this.skipSpacesAndComments();\n\n    // block\n    this.state.push('atrule');\n    keyframes.block = this.block(keyframes);\n    this.state.pop();\n\n    return keyframes;\n  },\n\n  /**\n   * literal\n   */\n\n  literal: function() {\n    return this.expect('literal').val;\n  },\n\n  /**\n   * ident space?\n   */\n\n  id: function() {\n    var tok = this.expect('ident');\n    this.accept('space');\n    return tok.val;\n  },\n\n  /**\n   *   ident\n   * | assignment\n   * | property\n   * | selector\n   */\n\n  ident: function() {\n    var i = 2\n      , la = this.lookahead(i).type;\n\n    while ('space' == la) la = this.lookahead(++i).type;\n\n    switch (la) {\n      // Assignment\n      case '=':\n      case '?=':\n      case '-=':\n      case '+=':\n      case '*=':\n      case '/=':\n      case '%=':\n        return this.assignment();\n      // Member\n      case '.':\n        if ('space' == this.lookahead(i - 1).type) return this.selector();\n        if (this._ident == this.peek()) return this.id();\n        while ('=' != this.lookahead(++i).type\n          && !~['[', ',', 'newline', 'indent', 'eos'].indexOf(this.lookahead(i).type)) ;\n        if ('=' == this.lookahead(i).type) {\n          this._ident = this.peek();\n          return this.expression();\n        } else if (this.looksLikeSelector() && this.stateAllowsSelector()) {\n          return this.selector();\n        }\n      // Assignment []=\n      case '[':\n        if (this._ident == this.peek()) return this.id();\n        while (']' != this.lookahead(i++).type\n          && 'selector' != this.lookahead(i).type\n          && 'eos' != this.lookahead(i).type) ;\n        if ('=' == this.lookahead(i).type) {\n          this._ident = this.peek();\n          return this.expression();\n        } else if (this.looksLikeSelector() && this.stateAllowsSelector()) {\n          return this.selector();\n        }\n      // Operation\n      case '-':\n      case '+':\n      case '/':\n      case '*':\n      case '%':\n      case '**':\n      case '&&':\n      case '||':\n      case '>':\n      case '<':\n      case '>=':\n      case '<=':\n      case '!=':\n      case '==':\n      case '?':\n      case 'in':\n      case 'is a':\n      case 'is defined':\n        // Prevent cyclic .ident, return literal\n        if (this._ident == this.peek()) {\n          return this.id();\n        } else {\n          this._ident = this.peek();\n          switch (this.currentState()) {\n            // unary op or selector in property / for\n            case 'for':\n            case 'selector':\n              return this.property();\n            // Part of a selector\n            case 'root':\n            case 'atblock':\n            case 'atrule':\n              return '[' == la\n                ? this.subscript()\n                : this.selector();\n            case 'function':\n            case 'conditional':\n              return this.looksLikeSelector()\n                ? this.selector()\n                : this.expression();\n            // Do not disrupt the ident when an operand\n            default:\n              return this.operand\n                ? this.id()\n                : this.expression();\n          }\n        }\n      // Selector or property\n      default:\n        switch (this.currentState()) {\n          case 'root':\n            return this.selector();\n          case 'for':\n          case 'selector':\n          case 'function':\n          case 'conditional':\n          case 'atblock':\n          case 'atrule':\n            return this.property();\n          default:\n            var id = this.id();\n            if ('interpolation' == this.previousState()) id.mixin = true;\n            return id;\n        }\n    }\n  },\n\n  /**\n   * '*'? (ident | '{' expression '}')+\n   */\n\n  interpolate: function() {\n    var node\n      , segs = []\n      , star;\n\n    star = this.accept('*');\n    if (star) segs.push(new nodes.Literal('*'));\n\n    while (true) {\n      if (this.accept('{')) {\n        this.state.push('interpolation');\n        segs.push(this.expression());\n        this.expect('}');\n        this.state.pop();\n      } else if (node = this.accept('-')){\n        segs.push(new nodes.Literal('-'));\n      } else if (node = this.accept('ident')){\n        segs.push(node.val);\n      } else {\n        break;\n      }\n    }\n    if (!segs.length) this.expect('ident');\n    return segs;\n  },\n\n  /**\n   *   property ':'? expression\n   * | ident\n   */\n\n  property: function() {\n    if (this.looksLikeSelector(true)) return this.selector();\n\n    // property\n    var ident = this.interpolate()\n      , prop = new nodes.Property(ident)\n      , ret = prop;\n\n    // optional ':'\n    this.accept('space');\n    if (this.accept(':')) this.accept('space');\n\n    this.state.push('property');\n    this.inProperty = true;\n    prop.expr = this.list();\n    if (prop.expr.isEmpty) ret = ident[0];\n    this.inProperty = false;\n    this.allowPostfix = true;\n    this.state.pop();\n\n    // optional ';'\n    this.accept(';');\n\n    return ret;\n  },\n\n  /**\n   *   selector ',' selector\n   * | selector newline selector\n   * | selector block\n   */\n\n  selector: function() {\n    var arr\n      , group = new nodes.Group\n      , scope = this.selectorScope\n      , isRoot = 'root' == this.currentState()\n      , selector;\n\n    do {\n      // Clobber newline after ,\n      this.accept('newline');\n\n      arr = this.selectorParts();\n\n      // Push the selector\n      if (isRoot && scope) arr.unshift(new nodes.Literal(scope + ' '));\n      if (arr.length) {\n        selector = new nodes.Selector(arr);\n        selector.lineno = arr[0].lineno;\n        selector.column = arr[0].column;\n        group.push(selector);\n      }\n    } while (this.accept(',') || this.accept('newline'));\n\n    if ('selector-parts' == this.currentState()) return group.nodes;\n\n    this.state.push('selector');\n    group.block = this.block(group);\n    this.state.pop();\n\n    return group;\n  },\n\n  selectorParts: function(){\n    var tok\n      , arr = [];\n\n    // Selector candidates,\n    // stitched together to\n    // form a selector.\n    while (tok = this.selectorToken()) {\n      debug.selector('%s', tok);\n      // Selector component\n      switch (tok.type) {\n        case '{':\n          this.skipSpaces();\n          var expr = this.expression();\n          this.skipSpaces();\n          this.expect('}');\n          arr.push(expr);\n          break;\n        case this.prefix && '.':\n          var literal = new nodes.Literal(tok.val + this.prefix);\n          literal.prefixed = true;\n          arr.push(literal);\n          break;\n        case 'comment':\n          // ignore comments\n          break;\n        case 'color':\n        case 'unit':\n          arr.push(new nodes.Literal(tok.val.raw));\n          break;\n        case 'space':\n          arr.push(new nodes.Literal(' '));\n          break;\n        case 'function':\n          arr.push(new nodes.Literal(tok.val.name + '('));\n          break;\n        case 'ident':\n          arr.push(new nodes.Literal(tok.val.name || tok.val.string));\n          break;\n        default:\n          arr.push(new nodes.Literal(tok.val));\n          if (tok.space) arr.push(new nodes.Literal(' '));\n      }\n    }\n\n    return arr;\n  },\n\n  /**\n   * ident ('=' | '?=') expression\n   */\n\n  assignment: function() {\n    var op\n      , node\n      , name = this.id().name;\n\n    if (op =\n         this.accept('=')\n      || this.accept('?=')\n      || this.accept('+=')\n      || this.accept('-=')\n      || this.accept('*=')\n      || this.accept('/=')\n      || this.accept('%=')) {\n      this.state.push('assignment');\n      var expr = this.list();\n      // @block support\n      if (expr.isEmpty) this.assignAtblock(expr);\n      node = new nodes.Ident(name, expr);\n      this.state.pop();\n\n      switch (op.type) {\n        case '?=':\n          var defined = new nodes.BinOp('is defined', node)\n            , lookup = new nodes.Expression;\n          lookup.push(new nodes.Ident(name));\n          node = new nodes.Ternary(defined, lookup, node);\n          break;\n        case '+=':\n        case '-=':\n        case '*=':\n        case '/=':\n        case '%=':\n          node.val = new nodes.BinOp(op.type[0], new nodes.Ident(name), expr);\n          break;\n      }\n    }\n\n    return node;\n  },\n\n  /**\n   *   definition\n   * | call\n   */\n\n  function: function() {\n    var parens = 1\n      , i = 2\n      , tok;\n\n    // Lookahead and determine if we are dealing\n    // with a function call or definition. Here\n    // we pair parens to prevent false negatives\n    out:\n    while (tok = this.lookahead(i++)) {\n      switch (tok.type) {\n        case 'function':\n        case '(':\n          ++parens;\n          break;\n        case ')':\n          if (!--parens) break out;\n          break;\n        case 'eos':\n          this.error('failed to find closing paren \")\"');\n      }\n    }\n\n    // Definition or call\n    switch (this.currentState()) {\n      case 'expression':\n        return this.functionCall();\n      default:\n        return this.looksLikeFunctionDefinition(i)\n          ? this.functionDefinition()\n          : this.expression();\n    }\n  },\n\n  /**\n   * url '(' (expression | urlchars)+ ')'\n   */\n\n  url: function() {\n    this.expect('function');\n    this.state.push('function arguments');\n    var args = this.args();\n    this.expect(')');\n    this.state.pop();\n    return new nodes.Call('url', args);\n  },\n\n  /**\n   * '+'? ident '(' expression ')' block?\n   */\n\n  functionCall: function() {\n    var withBlock = this.accept('+');\n    if ('url' == this.peek().val.name) return this.url();\n    var name = this.expect('function').val.name;\n    this.state.push('function arguments');\n    this.parens++;\n    var args = this.args();\n    this.expect(')');\n    this.parens--;\n    this.state.pop();\n    var call = new nodes.Call(name, args);\n    if (withBlock) {\n      this.state.push('function');\n      call.block = this.block(call);\n      this.state.pop();\n    }\n    return call;\n  },\n\n  /**\n   * ident '(' params ')' block\n   */\n\n  functionDefinition: function() {\n    var name = this.expect('function').val.name;\n\n    // params\n    this.state.push('function params');\n    this.skipWhitespace();\n    var params = this.params();\n    this.skipWhitespace();\n    this.expect(')');\n    this.state.pop();\n\n    // Body\n    this.state.push('function');\n    var fn = new nodes.Function(name, params);\n    fn.block = this.block(fn);\n    this.state.pop();\n    return new nodes.Ident(name, fn);\n  },\n\n  /**\n   *   ident\n   * | ident '...'\n   * | ident '=' expression\n   * | ident ',' ident\n   */\n\n  params: function() {\n    var tok\n      , node\n      , params = new nodes.Params;\n    while (tok = this.accept('ident')) {\n      this.accept('space');\n      params.push(node = tok.val);\n      if (this.accept('...')) {\n        node.rest = true;\n      } else if (this.accept('=')) {\n        node.val = this.expression();\n      }\n      this.skipWhitespace();\n      this.accept(',');\n      this.skipWhitespace();\n    }\n    return params;\n  },\n\n  /**\n   * (ident ':')? expression (',' (ident ':')? expression)*\n   */\n\n  args: function() {\n    var args = new nodes.Arguments\n      , keyword;\n\n    do {\n      // keyword\n      if ('ident' == this.peek().type && ':' == this.lookahead(2).type) {\n        keyword = this.next().val.string;\n        this.expect(':');\n        args.map[keyword] = this.expression();\n      // arg\n      } else {\n        args.push(this.expression());\n      }\n    } while (this.accept(','));\n\n    return args;\n  },\n\n  /**\n   * expression (',' expression)*\n   */\n\n  list: function() {\n    var node = this.expression();\n\n    while (this.accept(',')) {\n      if (node.isList) {\n        list.push(this.expression());\n      } else {\n        var list = new nodes.Expression(true);\n        list.push(node);\n        list.push(this.expression());\n        node = list;\n      }\n    }\n    return node;\n  },\n\n  /**\n   * negation+\n   */\n\n  expression: function() {\n    var node\n      , expr = new nodes.Expression;\n    this.state.push('expression');\n    while (node = this.negation()) {\n      if (!node) this.error('unexpected token {peek} in expression');\n      expr.push(node);\n    }\n    this.state.pop();\n    if (expr.nodes.length) {\n      expr.lineno = expr.nodes[0].lineno;\n      expr.column = expr.nodes[0].column;\n    }\n    return expr;\n  },\n\n  /**\n   *   'not' ternary\n   * | ternary\n   */\n\n  negation: function() {\n    if (this.accept('not')) {\n      return new nodes.UnaryOp('!', this.negation());\n    }\n    return this.ternary();\n  },\n\n  /**\n   * logical ('?' expression ':' expression)?\n   */\n\n  ternary: function() {\n    var node = this.logical();\n    if (this.accept('?')) {\n      var trueExpr = this.expression();\n      this.expect(':');\n      var falseExpr = this.expression();\n      node = new nodes.Ternary(node, trueExpr, falseExpr);\n    }\n    return node;\n  },\n\n  /**\n   * typecheck (('&&' | '||') typecheck)*\n   */\n\n  logical: function() {\n    var op\n      , node = this.typecheck();\n    while (op = this.accept('&&') || this.accept('||')) {\n      node = new nodes.BinOp(op.type, node, this.typecheck());\n    }\n    return node;\n  },\n\n  /**\n   * equality ('is a' equality)*\n   */\n\n  typecheck: function() {\n    var op\n      , node = this.equality();\n    while (op = this.accept('is a')) {\n      this.operand = true;\n      if (!node) this.error('illegal unary \"' + op + '\", missing left-hand operand');\n      node = new nodes.BinOp(op.type, node, this.equality());\n      this.operand = false;\n    }\n    return node;\n  },\n\n  /**\n   * in (('==' | '!=') in)*\n   */\n\n  equality: function() {\n    var op\n      , node = this.in();\n    while (op = this.accept('==') || this.accept('!=')) {\n      this.operand = true;\n      if (!node) this.error('illegal unary \"' + op + '\", missing left-hand operand');\n      node = new nodes.BinOp(op.type, node, this.in());\n      this.operand = false;\n    }\n    return node;\n  },\n\n  /**\n   * relational ('in' relational)*\n   */\n\n  in: function() {\n    var node = this.relational();\n    while (this.accept('in')) {\n      this.operand = true;\n      if (!node) this.error('illegal unary \"in\", missing left-hand operand');\n      node = new nodes.BinOp('in', node, this.relational());\n      this.operand = false;\n    }\n    return node;\n  },\n\n  /**\n   * range (('>=' | '<=' | '>' | '<') range)*\n   */\n\n  relational: function() {\n    var op\n      , node = this.range();\n    while (op =\n         this.accept('>=')\n      || this.accept('<=')\n      || this.accept('<')\n      || this.accept('>')\n      ) {\n      this.operand = true;\n      if (!node) this.error('illegal unary \"' + op + '\", missing left-hand operand');\n      node = new nodes.BinOp(op.type, node, this.range());\n      this.operand = false;\n    }\n    return node;\n  },\n\n  /**\n   * additive (('..' | '...') additive)*\n   */\n\n  range: function() {\n    var op\n      , node = this.additive();\n    if (op = this.accept('...') || this.accept('..')) {\n      this.operand = true;\n      if (!node) this.error('illegal unary \"' + op + '\", missing left-hand operand');\n      node = new nodes.BinOp(op.val, node, this.additive());\n      this.operand = false;\n    }\n    return node;\n  },\n\n  /**\n   * multiplicative (('+' | '-') multiplicative)*\n   */\n\n  additive: function() {\n    var op\n      , node = this.multiplicative();\n    while (op = this.accept('+') || this.accept('-')) {\n      this.operand = true;\n      node = new nodes.BinOp(op.type, node, this.multiplicative());\n      this.operand = false;\n    }\n    return node;\n  },\n\n  /**\n   * defined (('**' | '*' | '/' | '%') defined)*\n   */\n\n  multiplicative: function() {\n    var op\n      , node = this.defined();\n    while (op =\n         this.accept('**')\n      || this.accept('*')\n      || this.accept('/')\n      || this.accept('%')) {\n      this.operand = true;\n      if ('/' == op && this.inProperty && !this.parens) {\n        this.stash.push(new Token('literal', new nodes.Literal('/')));\n        this.operand = false;\n        return node;\n      } else {\n        if (!node) this.error('illegal unary \"' + op + '\", missing left-hand operand');\n        node = new nodes.BinOp(op.type, node, this.defined());\n        this.operand = false;\n      }\n    }\n    return node;\n  },\n\n  /**\n   *    unary 'is defined'\n   *  | unary\n   */\n\n  defined: function() {\n    var node = this.unary();\n    if (this.accept('is defined')) {\n      if (!node) this.error('illegal unary \"is defined\", missing left-hand operand');\n      node = new nodes.BinOp('is defined', node);\n    }\n    return node;\n  },\n\n  /**\n   *   ('!' | '~' | '+' | '-') unary\n   * | subscript\n   */\n\n  unary: function() {\n    var op\n      , node;\n    if (op =\n         this.accept('!')\n      || this.accept('~')\n      || this.accept('+')\n      || this.accept('-')) {\n      this.operand = true;\n      node = this.unary();\n      if (!node) this.error('illegal unary \"' + op + '\"');\n      node = new nodes.UnaryOp(op.type, node);\n      this.operand = false;\n      return node;\n    }\n    return this.subscript();\n  },\n\n  /**\n   *   member ('[' expression ']')+ '='?\n   * | member\n   */\n\n  subscript: function() {\n    var node = this.member()\n      , id;\n    while (this.accept('[')) {\n      node = new nodes.BinOp('[]', node, this.expression());\n      this.expect(']');\n    }\n    // TODO: TernaryOp :)\n    if (this.accept('=')) {\n      node.op += '=';\n      node.val = this.list();\n      // @block support\n      if (node.val.isEmpty) this.assignAtblock(node.val);\n    }\n    return node;\n  },\n\n  /**\n   *   primary ('.' id)+ '='?\n   * | primary\n   */\n  \n  member: function() {\n    var node = this.primary();\n    if (node) {\n      while (this.accept('.')) {\n        var id = new nodes.Ident(this.expect('ident').val.string);\n        node = new nodes.Member(node, id);\n      }\n      this.skipSpaces();\n      if (this.accept('=')) {\n        node.val = this.list();\n        // @block support\n        if (node.val.isEmpty) this.assignAtblock(node.val);\n      }\n    }\n    return node;\n  },\n\n  /**\n   *   '{' '}'\n   * | '{' pair (ws pair)* '}'\n   */\n\n  object: function(){\n    var obj = new nodes.Object\n      , id, val, comma;\n    this.expect('{');\n    this.skipWhitespace();\n\n    while (!this.accept('}')) {\n      if (this.accept('comment')\n        || this.accept('newline')) continue;\n\n      if (!comma) this.accept(',');\n      id = this.accept('ident') || this.accept('string');\n      if (!id) this.error('expected \"ident\" or \"string\", got {peek}');\n      id = id.val.hash;\n      this.skipSpacesAndComments();\n      this.expect(':');\n      val = this.expression();\n      obj.set(id, val);\n      comma = this.accept(',');\n      this.skipWhitespace();\n    }\n\n    return obj;\n  },\n\n  /**\n   *   unit\n   * | null\n   * | color\n   * | string\n   * | ident\n   * | boolean\n   * | literal\n   * | object\n   * | atblock\n   * | atrule\n   * | '(' expression ')' '%'?\n   */\n\n  primary: function() {\n    var tok;\n    this.skipSpaces();\n\n    // Parenthesis\n    if (this.accept('(')) {\n      ++this.parens;\n      var expr = this.expression()\n        , paren = this.expect(')');\n      --this.parens;\n      if (this.accept('%')) expr.push(new nodes.Ident('%'));\n      tok = this.peek();\n      // (1 + 2)px, (1 + 2)em, etc.\n      if (!paren.space\n        && 'ident' == tok.type\n        && ~units.indexOf(tok.val.string)) {\n        expr.push(new nodes.Ident(tok.val.string));\n        this.next();\n      }\n      return expr;\n    }\n\n    tok = this.peek();\n\n    // Primitive\n    switch (tok.type) {\n      case 'null':\n      case 'unit':\n      case 'color':\n      case 'string':\n      case 'literal':\n      case 'boolean':\n      case 'comment':\n        return this.next().val;\n      case !this.cond && '{':\n        return this.object();\n      case 'atblock':\n        return this.atblock();\n      // property lookup\n      case 'atrule':\n        var id = new nodes.Ident(this.next().val);\n        id.property = true;\n        return id;\n      case 'ident':\n        return this.ident();\n      case 'function':\n        return tok.anonymous\n          ? this.functionDefinition()\n          : this.functionCall();\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/lexer.js":"\n/*!\n * Stylus - Lexer\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Token = require('./token')\n  , nodes = require('./nodes')\n  , errors = require('./errors');\n\n/**\n * Expose `Lexer`.\n */\n\nexports = module.exports = Lexer;\n\n/**\n * Operator aliases.\n */\n\nvar alias = {\n    'and': '&&'\n  , 'or': '||'\n  , 'is': '=='\n  , 'isnt': '!='\n  , 'is not': '!='\n  , ':=': '?='\n};\n\n/**\n * Initialize a new `Lexer` with the given `str` and `options`.\n *\n * @param {String} str\n * @param {Object} options\n * @api private\n */\n\nfunction Lexer(str, options) {\n  options = options || {};\n  this.stash = [];\n  this.indentStack = [];\n  this.indentRe = null;\n  this.lineno = 1;\n  this.column = 1;\n\n  // HACK!\n  function comment(str, val, offset, s) {\n    var inComment = s.lastIndexOf('/*', offset) > s.lastIndexOf('*/', offset)\n      , commentIdx = s.lastIndexOf('//', offset)\n      , i = s.lastIndexOf('\\n', offset)\n      , double = 0\n      , single = 0;\n\n    if (~commentIdx && commentIdx > i) {\n      while (i != offset) {\n        if (\"'\" == s[i]) single ? single-- : single++;\n        if ('\"' == s[i]) double ? double-- : double++;\n\n        if ('/' == s[i] && '/' == s[i + 1]) {\n          inComment = !single && !double;\n          break;\n        }\n        ++i;\n      }\n    }\n\n    return inComment\n      ? str\n      : val + '\\r';\n  };\n\n  // Remove UTF-8 BOM.\n  if ('\\uFEFF' == str.charAt(0)) str = str.slice(1);\n\n  this.str = str\n    .replace(/\\s+$/, '\\n')\n    .replace(/\\r\\n?/g, '\\n')\n    .replace(/\\\\ *\\n/g, '\\r')\n    .replace(/([,(:](?!\\/\\/[^ ])) *(?:\\/\\/[^\\n]*|\\/\\*.*?\\*\\/)?\\n\\s*/g, comment)\n    .replace(/\\s*\\n[ \\t]*([,)])/g, comment);\n};\n\n/**\n * Lexer prototype.\n */\n\nLexer.prototype = {\n  \n  /**\n   * Custom inspect.\n   */\n  \n  inspect: function(){\n    var tok\n      , tmp = this.str\n      , buf = [];\n    while ('eos' != (tok = this.next()).type) {\n      buf.push(tok.inspect());\n    }\n    this.str = tmp;\n    return buf.concat(tok.inspect()).join('\\n');\n  },\n\n  /**\n   * Lookahead `n` tokens.\n   *\n   * @param {Number} n\n   * @return {Object}\n   * @api private\n   */\n  \n  lookahead: function(n){\n    var fetch = n - this.stash.length;\n    while (fetch-- > 0) this.stash.push(this.advance());\n    return this.stash[--n];\n  },\n  \n  /**\n   * Consume the given `len`.\n   *\n   * @param {Number|Array} len\n   * @api private\n   */\n\n  skip: function(len){\n    var chunk = len[0];\n    len = chunk ? chunk.length : len;\n    this.str = this.str.substr(len);\n    if (chunk) {\n      this.move(chunk);\n    } else {\n      this.column += len;\n    }\n  },\n\n  /**\n   * Move current line and column position.\n   *\n   * @param {String} str\n   * @api private\n   */\n\n  move: function(str){\n    var lines = str.match(/\\n/g)\n      , idx = str.lastIndexOf('\\n');\n\n    if (lines) this.lineno += lines.length;\n    this.column = ~idx\n      ? str.length - idx\n      : this.column + str.length;\n  },\n\n  /**\n   * Fetch next token including those stashed by peek.\n   *\n   * @return {Token}\n   * @api private\n   */\n\n  next: function() {\n    var tok = this.stashed() || this.advance();\n    this.prev = tok;\n    return tok;\n  },\n\n  /**\n   * Check if the current token is a part of selector.\n   *\n   * @return {Boolean}\n   * @api private\n   */\n\n  isPartOfSelector: function() {\n    var tok = this.stash[this.stash.length - 1] || this.prev;\n    switch (tok && tok.type) {\n      // #for\n      case 'color':\n        return 2 == tok.val.raw.length;\n      // .or\n      case '.':\n      // [is]\n      case '[':\n        return true;\n    }\n    return false;\n  },\n\n  /**\n   * Fetch next token.\n   *\n   * @return {Token}\n   * @api private\n   */\n\n  advance: function() {\n    var column = this.column\n      , line = this.lineno\n      , tok = this.eos()\n      || this.null()\n      || this.sep()\n      || this.keyword()\n      || this.urlchars()\n      || this.comment()\n      || this.newline()\n      || this.escaped()\n      || this.important()\n      || this.literal()\n      || this.anonFunc()\n      || this.atrule()\n      || this.function()\n      || this.brace()\n      || this.paren()\n      || this.color()\n      || this.string()\n      || this.unit()\n      || this.namedop()\n      || this.boolean()\n      || this.unicode()\n      || this.ident()\n      || this.op()\n      || this.eol()\n      || this.space()\n      || this.selector();\n    tok.lineno = line;\n    tok.column = column;\n    return tok;\n  },\n\n  /**\n   * Lookahead a single token.\n   *\n   * @return {Token}\n   * @api private\n   */\n  \n  peek: function() {\n    return this.lookahead(1);\n  },\n  \n  /**\n   * Return the next possibly stashed token.\n   *\n   * @return {Token}\n   * @api private\n   */\n\n  stashed: function() {\n    return this.stash.shift();\n  },\n\n  /**\n   * EOS | trailing outdents.\n   */\n\n  eos: function() {\n    if (this.str.length) return;\n    if (this.indentStack.length) {\n      this.indentStack.shift();\n      return new Token('outdent');\n    } else {\n      return new Token('eos');\n    }\n  },\n\n  /**\n   * url char\n   */\n\n  urlchars: function() {\n    var captures;\n    if (!this.isURL) return;\n    if (captures = /^[\\/:@.;?&=*!,<>#%0-9]+/.exec(this.str)) {\n      this.skip(captures);\n      return new Token('literal', new nodes.Literal(captures[0]));\n    }\n  },\n\n  /**\n   * ';' [ \\t]*\n   */\n\n  sep: function() {\n    var captures;\n    if (captures = /^;[ \\t]*/.exec(this.str)) {\n      this.skip(captures);\n      return new Token(';');\n    }\n  },\n\n  /**\n   * '\\r'\n   */\n\n  eol: function() {\n    if ('\\r' == this.str[0]) {\n      ++this.lineno;\n      this.skip(1);\n      return this.advance();\n    }\n  },\n  \n  /**\n   * ' '+\n   */\n\n  space: function() {\n    var captures;\n    if (captures = /^([ \\t]+)/.exec(this.str)) {\n      this.skip(captures);\n      return new Token('space');\n    }\n  },\n  \n  /**\n   * '\\\\' . ' '*\n   */\n   \n  escaped: function() {\n    var captures;\n    if (captures = /^\\\\(.)[ \\t]*/.exec(this.str)) {\n      var c = captures[1];\n      this.skip(captures);\n      return new Token('ident', new nodes.Literal(c));\n    }\n  },\n  \n  /**\n   * '@css' ' '* '{' .* '}' ' '*\n   */\n  \n  literal: function() {\n    // HACK attack !!!\n    var captures;\n    if (captures = /^@css[ \\t]*\\{/.exec(this.str)) {\n      this.skip(captures);\n      var c\n        , braces = 1\n        , css = ''\n        , node;\n      while (c = this.str[0]) {\n        this.str = this.str.substr(1);\n        switch (c) {\n          case '{': ++braces; break;\n          case '}': --braces; break;\n          case '\\n':\n          case '\\r':\n            ++this.lineno;\n            break;\n        }\n        css += c;\n        if (!braces) break;\n      }\n      css = css.replace(/\\s*}$/, '');\n      node = new nodes.Literal(css);\n      node.css = true;\n      return new Token('literal', node);\n    }\n  },\n  \n  /**\n   * '!important' ' '*\n   */\n  \n  important: function() {\n    var captures;\n    if (captures = /^!important[ \\t]*/.exec(this.str)) {\n      this.skip(captures);\n      return new Token('ident', new nodes.Literal('!important'));\n    }\n  },\n  \n  /**\n   * '{' | '}'\n   */\n  \n  brace: function() {\n    var captures;\n    if (captures = /^([{}])/.exec(this.str)) {\n      this.skip(1);\n      var brace = captures[1];\n      return new Token(brace, brace);\n    }\n  },\n  \n  /**\n   * '(' | ')' ' '*\n   */\n  \n  paren: function() {\n    var captures;\n    if (captures = /^([()])([ \\t]*)/.exec(this.str)) {\n      var paren = captures[1];\n      this.skip(captures);\n      if (')' == paren) this.isURL = false;\n      var tok = new Token(paren, paren);\n      tok.space = captures[2];\n      return tok;\n    }\n  },\n  \n  /**\n   * 'null'\n   */\n  \n  null: function() {\n    var captures\n      , tok;\n    if (captures = /^(null)\\b[ \\t]*/.exec(this.str)) {\n      this.skip(captures);\n      if (this.isPartOfSelector()) {\n        tok = new Token('ident', new nodes.Ident(captures[0]));\n      } else {\n        tok = new Token('null', nodes.null);\n      }\n      return tok;\n    }\n  },\n  \n  /**\n   *   'if'\n   * | 'else'\n   * | 'unless'\n   * | 'return'\n   * | 'for'\n   * | 'in'\n   */\n  \n  keyword: function() {\n    var captures\n      , tok;\n    if (captures = /^(return|if|else|unless|for|in)\\b[ \\t]*/.exec(this.str)) {\n      var keyword = captures[1];\n      this.skip(captures);\n      if (this.isPartOfSelector()) {\n        tok = new Token('ident', new nodes.Ident(captures[0]));\n      } else {\n        tok = new Token(keyword, keyword);\n      }\n      return tok;\n    }\n  },\n  \n  /**\n   *   'not'\n   * | 'and'\n   * | 'or'\n   * | 'is'\n   * | 'is not'\n   * | 'isnt'\n   * | 'is a'\n   * | 'is defined'\n   */\n  \n  namedop: function() {\n    var captures\n      , tok;\n    if (captures = /^(not|and|or|is a|is defined|isnt|is not|is)(?!-)\\b([ \\t]*)/.exec(this.str)) {\n      var op = captures[1];\n      this.skip(captures);\n      if (this.isPartOfSelector()) {\n        tok = new Token('ident', new nodes.Ident(captures[0]));\n      } else {\n        op = alias[op] || op;\n        tok = new Token(op, op);\n      }\n      tok.space = captures[2];\n      return tok;\n    }\n  },\n\n  /**\n   *   ','\n   * | '+'\n   * | '+='\n   * | '-'\n   * | '-='\n   * | '*'\n   * | '*='\n   * | '/'\n   * | '/='\n   * | '%'\n   * | '%='\n   * | '**'\n   * | '!'\n   * | '&'\n   * | '&&'\n   * | '||'\n   * | '>'\n   * | '>='\n   * | '<'\n   * | '<='\n   * | '='\n   * | '=='\n   * | '!='\n   * | '!'\n   * | '~'\n   * | '?='\n   * | ':='\n   * | '?'\n   * | ':'\n   * | '['\n   * | ']'\n   * | '.'\n   * | '..'\n   * | '...'\n   */\n  \n  op: function() {\n    var captures;\n    if (captures = /^([.]{1,3}|&&|\\|\\||[!<>=?:]=|\\*\\*|[-+*\\/%]=?|[,=?:!~<>&\\[\\]])([ \\t]*)/.exec(this.str)) {\n      var op = captures[1];\n      this.skip(captures);\n      op = alias[op] || op;\n      var tok = new Token(op, op);\n      tok.space = captures[2];\n      this.isURL = false;\n      return tok;\n    }\n  },\n\n  /**\n   * '@('\n   */\n\n  anonFunc: function() {\n    var tok;\n    if ('@' == this.str[0] && '(' == this.str[1]) {\n      this.skip(2);\n      tok = new Token('function', new nodes.Ident('anonymous'));\n      tok.anonymous = true;\n      return tok;\n    }\n  },\n\n  /**\n   * '@' (-(\\w+)-)?[a-zA-Z0-9-_]+\n   */\n\n  atrule: function() {\n    var captures;\n    if (captures = /^@(?:-(\\w+)-)?([a-zA-Z0-9-_]+)[ \\t]*/.exec(this.str)) {\n      this.skip(captures);\n      var vendor = captures[1]\n        , type = captures[2]\n        , tok;\n      switch (type) {\n        case 'require':\n        case 'import':\n        case 'charset':\n        case 'namespace':\n        case 'media':\n        case 'scope':\n        case 'supports':\n          return new Token(type);\n        case 'document':\n          return new Token('-moz-document');\n        case 'block':\n          return new Token('atblock');\n        case 'extend':\n        case 'extends':\n          return new Token('extend');\n        case 'keyframes':\n          return new Token(type, vendor);\n        default:\n          return new Token('atrule', (vendor ? '-' + vendor + '-' + type : type));\n      }\n    }\n  },\n\n  /**\n   * '//' *\n   */\n  \n  comment: function() {\n    // Single line\n    if ('/' == this.str[0] && '/' == this.str[1]) {\n      var end = this.str.indexOf('\\n');\n      if (-1 == end) end = this.str.length;\n      this.skip(end);\n      return this.advance();\n    }\n\n    // Multi-line\n    if ('/' == this.str[0] && '*' == this.str[1]) {\n      var end = this.str.indexOf('*/');\n      if (-1 == end) end = this.str.length;\n      var str = this.str.substr(0, end + 2)\n        , lines = str.split(/\\n|\\r/).length - 1\n        , suppress = true\n        , inline = false;\n      this.lineno += lines;\n      this.skip(end + 2);\n      // output\n      if ('!' == str[2]) {\n        str = str.replace('*!', '*');\n        suppress = false;\n      }\n      if (this.prev && ';' == this.prev.type) inline = true;\n      return new Token('comment', new nodes.Comment(str, suppress, inline));\n    }\n  },\n\n  /**\n   * 'true' | 'false'\n   */\n  \n  boolean: function() {\n    var captures;\n    if (captures = /^(true|false)\\b([ \\t]*)/.exec(this.str)) {\n      var val = nodes.Boolean('true' == captures[1]);\n      this.skip(captures);\n      var tok = new Token('boolean', val);\n      tok.space = captures[2];\n      return tok;\n    }\n  },\n\n  /**\n   * 'U+' [0-9A-Fa-f?]{1,6}(?:-[0-9A-Fa-f]{1,6})?\n   */\n\n  unicode: function() {\n    var captures;\n    if (captures = /^u\\+[0-9a-f?]{1,6}(?:-[0-9a-f]{1,6})?/i.exec(this.str)) {\n      this.skip(captures);\n      return new Token('literal', new nodes.Literal(captures[0]));\n    }\n  },\n\n  /**\n   * -*[_a-zA-Z$] [-\\w\\d$]* '('\n   */\n  \n  function: function() {\n    var captures;\n    if (captures = /^(-*[_a-zA-Z$][-\\w\\d$]*)\\(([ \\t]*)/.exec(this.str)) {\n      var name = captures[1];\n      this.skip(captures);\n      this.isURL = 'url' == name;\n      var tok = new Token('function', new nodes.Ident(name));\n      tok.space = captures[2];\n      return tok;\n    } \n  },\n\n  /**\n   * -*[_a-zA-Z$] [-\\w\\d$]*\n   */\n  \n  ident: function() {\n    var captures;\n    if (captures = /^-*[_a-zA-Z$][-\\w\\d$]*/.exec(this.str)) {\n      this.skip(captures);\n      return new Token('ident', new nodes.Ident(captures[0]));\n    }\n  },\n\n  /**\n   * '\\n' ' '+\n   */\n\n  newline: function() {\n    var captures, re;\n\n    // we have established the indentation regexp\n    if (this.indentRe){\n      captures = this.indentRe.exec(this.str);\n    // figure out if we are using tabs or spaces\n    } else {\n      // try tabs\n      re = /^\\n([\\t]*)[ \\t]*/;\n      captures = re.exec(this.str);\n\n      // nope, try spaces\n      if (captures && !captures[1].length) {\n        re = /^\\n([ \\t]*)/;\n        captures = re.exec(this.str);\n      }\n\n      // established\n      if (captures && captures[1].length) this.indentRe = re;\n    }\n\n\n    if (captures) {\n      var tok\n        , indents = captures[1].length;\n\n      this.skip(captures);\n      if (this.str[0] === ' ' || this.str[0] === '\\t') {\n        throw new errors.SyntaxError('Invalid indentation. You can use tabs or spaces to indent, but not both.');\n      }\n\n      // Blank line\n      if ('\\n' == this.str[0]) return this.advance();\n\n      // Outdent\n      if (this.indentStack.length && indents < this.indentStack[0]) {\n        while (this.indentStack.length && this.indentStack[0] > indents) {\n          this.stash.push(new Token('outdent'));\n          this.indentStack.shift();\n        }\n        tok = this.stash.pop();\n      // Indent\n      } else if (indents && indents != this.indentStack[0]) {\n        this.indentStack.unshift(indents);\n        tok = new Token('indent');\n      // Newline\n      } else {\n        tok = new Token('newline');\n      }\n\n      return tok;\n    }\n  },\n\n  /**\n   * '-'? (digit+ | digit* '.' digit+) unit\n   */\n\n  unit: function() {\n    var captures;\n    if (captures = /^(-)?(\\d+\\.\\d+|\\d+|\\.\\d+)(%|[a-zA-Z]+)?[ \\t]*/.exec(this.str)) {\n      this.skip(captures);\n      var n = parseFloat(captures[2]);\n      if ('-' == captures[1]) n = -n;\n      var node = new nodes.Unit(n, captures[3]);\n      node.raw = captures[0];\n      return new Token('unit', node);\n    }\n  },\n\n  /**\n   * '\"' [^\"]+ '\"' | \"'\"\" [^']+ \"'\"\n   */\n\n  string: function() {\n    var captures;\n    if (captures = /^(\"[^\"]*\"|'[^']*')[ \\t]*/.exec(this.str)) {\n      var str = captures[1]\n        , quote = captures[0][0];\n      this.skip(captures);\n      str = str.slice(1,-1).replace(/\\\\n/g, '\\n');\n      return new Token('string', new nodes.String(str, quote));\n    }\n  },\n\n  /**\n   * #rrggbbaa | #rrggbb | #rgba | #rgb | #nn | #n\n   */\n\n  color: function() {\n    return this.rrggbbaa()\n      || this.rrggbb()\n      || this.rgba()\n      || this.rgb()\n      || this.nn()\n      || this.n()\n  },\n\n  /**\n   * #n\n   */\n  \n  n: function() {\n    var captures;\n    if (captures = /^#([a-fA-F0-9]{1})[ \\t]*/.exec(this.str)) {\n      this.skip(captures);\n      var n = parseInt(captures[1] + captures[1], 16)\n        , color = new nodes.RGBA(n, n, n, 1);\n      color.raw = captures[0];\n      return new Token('color', color); \n    }\n  },\n\n  /**\n   * #nn\n   */\n  \n  nn: function() {\n    var captures;\n    if (captures = /^#([a-fA-F0-9]{2})[ \\t]*/.exec(this.str)) {\n      this.skip(captures);\n      var n = parseInt(captures[1], 16)\n        , color = new nodes.RGBA(n, n, n, 1);\n      color.raw = captures[0];\n      return new Token('color', color); \n    }\n  },\n\n  /**\n   * #rgb\n   */\n  \n  rgb: function() {\n    var captures;\n    if (captures = /^#([a-fA-F0-9]{3})[ \\t]*/.exec(this.str)) {\n      this.skip(captures);\n      var rgb = captures[1]\n        , r = parseInt(rgb[0] + rgb[0], 16)\n        , g = parseInt(rgb[1] + rgb[1], 16)\n        , b = parseInt(rgb[2] + rgb[2], 16)\n        , color = new nodes.RGBA(r, g, b, 1);\n      color.raw = captures[0];\n      return new Token('color', color); \n    }\n  },\n  \n  /**\n   * #rgba\n   */\n  \n  rgba: function() {\n    var captures;\n    if (captures = /^#([a-fA-F0-9]{4})[ \\t]*/.exec(this.str)) {\n      this.skip(captures);\n      var rgb = captures[1]\n        , r = parseInt(rgb[0] + rgb[0], 16)\n        , g = parseInt(rgb[1] + rgb[1], 16)\n        , b = parseInt(rgb[2] + rgb[2], 16)\n        , a = parseInt(rgb[3] + rgb[3], 16)\n        , color = new nodes.RGBA(r, g, b, a/255);\n      color.raw = captures[0];\n      return new Token('color', color); \n    }\n  },\n  \n  /**\n   * #rrggbb\n   */\n  \n  rrggbb: function() {\n    var captures;\n    if (captures = /^#([a-fA-F0-9]{6})[ \\t]*/.exec(this.str)) {\n      this.skip(captures);\n      var rgb = captures[1]\n        , r = parseInt(rgb.substr(0, 2), 16)\n        , g = parseInt(rgb.substr(2, 2), 16)\n        , b = parseInt(rgb.substr(4, 2), 16)\n        , color = new nodes.RGBA(r, g, b, 1);\n      color.raw = captures[0];\n      return new Token('color', color); \n    }\n  },\n  \n  /**\n   * #rrggbbaa\n   */\n  \n  rrggbbaa: function() {\n    var captures;\n    if (captures = /^#([a-fA-F0-9]{8})[ \\t]*/.exec(this.str)) {\n      this.skip(captures);\n      var rgb = captures[1]\n        , r = parseInt(rgb.substr(0, 2), 16)\n        , g = parseInt(rgb.substr(2, 2), 16)\n        , b = parseInt(rgb.substr(4, 2), 16)\n        , a = parseInt(rgb.substr(6, 2), 16)\n        , color = new nodes.RGBA(r, g, b, a/255);\n      color.raw = captures[0];\n      return new Token('color', color); \n    }\n  },\n  \n  /**\n   * ^|[^\\n,;]+\n   */\n  \n  selector: function() {\n    var captures;\n    if (captures = /^\\^|.*?(?=\\/\\/(?![^\\[]*\\])|[,\\n{])/.exec(this.str)) {\n      var selector = captures[0];\n      this.skip(captures);\n      return new Token('selector', selector);\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/token.js":"\n/*!\n * Stylus - Token\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar inspect = require('util').inspect;\n\n/**\n * Initialize a new `Token` with the given `type` and `val`.\n *\n * @param {String} type\n * @param {Mixed} val\n * @api private\n */\n\nvar Token = exports = module.exports = function Token(type, val) {\n  this.type = type;\n  this.val = val;\n};\n\n/**\n * Custom inspect.\n *\n * @return {String}\n * @api public\n */\n\nToken.prototype.inspect = function(){\n  var val = ' ' + inspect(this.val);\n  return '[Token:' + this.lineno + ':' + this.column + ' '\n    + '\\x1b[32m' + this.type + '\\x1b[0m'\n    + '\\x1b[33m' + (this.val ? val : '') + '\\x1b[0m'\n    + ']';\n};\n\n/**\n * Return type or val.\n *\n * @return {String}\n * @api public\n */\n\nToken.prototype.toString = function(){\n  return (undefined === this.val\n    ? this.type\n    : this.val).toString();\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/index.js":"\n/*!\n * Stylus - nodes\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Constructors\n */\n\nexports.Node = require('./node');\nexports.Root = require('./root');\nexports.Null = require('./null');\nexports.Each = require('./each');\nexports.If = require('./if');\nexports.Call = require('./call');\nexports.UnaryOp = require('./unaryop');\nexports.BinOp = require('./binop');\nexports.Ternary = require('./ternary');\nexports.Block = require('./block');\nexports.Unit = require('./unit');\nexports.String = require('./string');\nexports.HSLA = require('./hsla');\nexports.RGBA = require('./rgba');\nexports.Ident = require('./ident');\nexports.Group = require('./group');\nexports.Literal = require('./literal');\nexports.Boolean = require('./boolean');\nexports.Return = require('./return');\nexports.Media = require('./media');\nexports.QueryList = require('./query-list');\nexports.Query = require('./query');\nexports.Feature = require('./feature');\nexports.Params = require('./params');\nexports.Comment = require('./comment');\nexports.Keyframes = require('./keyframes');\nexports.Member = require('./member');\nexports.Charset = require('./charset');\nexports.Namespace = require('./namespace');\nexports.Import = require('./import');\nexports.Extend = require('./extend');\nexports.Object = require('./object');\nexports.Function = require('./function');\nexports.Property = require('./property');\nexports.Selector = require('./selector');\nexports.Expression = require('./expression');\nexports.Arguments = require('./arguments');\nexports.Atblock = require('./atblock');\nexports.Atrule = require('./atrule');\nexports.Supports = require('./supports');\n\n/**\n * Singletons.\n */\n\nexports.true = new exports.Boolean(true);\nexports.false = new exports.Boolean(false);\nexports.null = new exports.Null;\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/node.js":"\n/*!\n * Stylus - Node\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Evaluator = require('../visitor/evaluator')\n  , utils = require('../utils')\n  , nodes = require('./');\n\n/**\n * Initialize a new `CoercionError` with the given `msg`.\n *\n * @param {String} msg\n * @api private\n */\n\nfunction CoercionError(msg) {\n  this.name = 'CoercionError'\n  this.message = msg\n  Error.captureStackTrace(this, CoercionError);\n}\n\n/**\n * Inherit from `Error.prototype`.\n */\n\nCoercionError.prototype.__proto__ = Error.prototype;\n\n/**\n * Node constructor.\n *\n * @api public\n */\n\nvar Node = module.exports = function Node(){\n  this.lineno = nodes.lineno || 1;\n  this.column = nodes.column || 1;\n  this.filename = nodes.filename;\n};\n\nNode.prototype = {\n  constructor: Node,\n\n  /**\n   * Return this node.\n   *\n   * @return {Node}\n   * @api public\n   */\n\n  get first() {\n    return this;\n  },\n\n  /**\n   * Return hash.\n   *\n   * @return {String}\n   * @api public\n   */\n\n  get hash() {\n    return this.val;\n  },\n\n  /**\n   * Return node name.\n   *\n   * @return {String}\n   * @api public\n   */\n\n  get nodeName() {\n    return this.constructor.name.toLowerCase();\n  },\n\n  /**\n   * Return this node.\n   * \n   * @return {Node}\n   * @api public\n   */\n\n  clone: function(){\n    return this;\n  },\n\n  /**\n   * Return a JSON representation of this node.\n   *\n   * @return {Object}\n   * @api public\n   */\n\n  toJSON: function(){\n    return {\n      lineno: this.lineno,\n      column: this.column,\n      filename: this.filename\n    };\n  },\n\n  /**\n   * Nodes by default evaluate to themselves.\n   *\n   * @return {Node}\n   * @api public\n   */\n\n  eval: function(){\n    return new Evaluator(this).evaluate();\n  },\n\n  /**\n   * Return true.\n   *\n   * @return {Boolean}\n   * @api public\n   */\n\n  toBoolean: function(){\n    return nodes.true;\n  },\n\n  /**\n   * Return the expression, or wrap this node in an expression.\n   *\n   * @return {Expression}\n   * @api public\n   */\n\n  toExpression: function(){\n    if ('expression' == this.nodeName) return this;\n    var expr = new nodes.Expression;\n    expr.push(this);\n    return expr;\n  },\n\n  /**\n   * Return false if `op` is generally not coerced.\n   *\n   * @param {String} op\n   * @return {Boolean}\n   * @api private\n   */\n\n  shouldCoerce: function(op){\n    switch (op) {\n      case 'is a':\n      case 'in':\n      case '||':\n      case '&&':\n        return false;\n      default:\n        return true;\n    }\n  },\n\n  /**\n   * Operate on `right` with the given `op`.\n   *\n   * @param {String} op\n   * @param {Node} right\n   * @return {Node}\n   * @api public\n   */\n\n  operate: function(op, right){\n    switch (op) {\n      case 'is a':\n        if ('string' == right.first.nodeName) {\n          return nodes.Boolean(this.nodeName == right.val);\n        } else {\n          throw new Error('\"is a\" expects a string, got ' + right.toString());\n        }\n      case '==':\n        return nodes.Boolean(this.hash == right.hash);\n      case '!=':\n        return nodes.Boolean(this.hash != right.hash);\n      case '>=':\n        return nodes.Boolean(this.hash >= right.hash);\n      case '<=':\n        return nodes.Boolean(this.hash <= right.hash);\n      case '>':\n        return nodes.Boolean(this.hash > right.hash);\n      case '<':\n        return nodes.Boolean(this.hash < right.hash);\n      case '||':\n        return this.toBoolean().isTrue\n          ? this\n          : right;\n      case 'in':\n        var vals = utils.unwrap(right).nodes\n          , len = vals && vals.length\n          , hash = this.hash;\n        if (!vals) throw new Error('\"in\" given invalid right-hand operand, expecting an expression');\n\n        // 'prop' in obj\n        if (1 == len && 'object' == vals[0].nodeName) {\n          return nodes.Boolean(vals[0].has(this.hash));\n        }\n\n        for (var i = 0; i < len; ++i) {\n          if (hash == vals[i].hash) {\n            return nodes.true;\n          }\n        }\n        return nodes.false;\n      case '&&':\n        var a = this.toBoolean()\n          , b = right.toBoolean();\n        return a.isTrue && b.isTrue\n          ? right\n          : a.isFalse\n            ? this\n            : right;\n      default:\n        if ('[]' == op) {\n          var msg = 'cannot perform '\n            + this\n            + '[' + right + ']';\n        } else {\n          var msg = 'cannot perform'\n            + ' ' + this\n            + ' ' + op\n            + ' ' + right;\n        }\n        throw new Error(msg);\n    }\n  },\n\n  /**\n   * Default coercion throws.\n   *\n   * @param {Node} other\n   * @return {Node}\n   * @api public\n   */\n\n  coerce: function(other){\n    if (other.nodeName == this.nodeName) return other;\n    throw new CoercionError('cannot coerce ' + other + ' to ' + this.nodeName);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/visitor/evaluator.js":"\n/*!\n * Stylus - Evaluator\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Visitor = require('./')\n  , units = require('../units')\n  , nodes = require('../nodes')\n  , Stack = require('../stack')\n  , Frame = require('../stack/frame')\n  , utils = require('../utils')\n  , bifs = require('../functions')\n  , dirname = require('path').dirname\n  , colors = require('../colors')\n  , debug = require('debug')('stylus:evaluator')\n  , fs = require('fs');\n\n/**\n * Import `file` and return Block node.\n *\n * @api private\n */\nfunction importFile(node, file, literal) {\n  var importStack = this.importStack\n    , Parser = require('../parser')\n    , stat;\n\n  // Handling the `require`\n  if (node.once) {\n    if (this.requireHistory[file]) return nodes.null;\n    this.requireHistory[file] = true;\n\n    if (literal && !this.includeCSS) {\n      return node;\n    }\n  }\n\n  // Avoid overflows from importing the same file over again\n  if (~importStack.indexOf(file))\n    throw new Error('import loop has been found');\n\n  var str = fs.readFileSync(file, 'utf8');\n\n  // shortcut for empty files\n  if (!str.trim()) return nodes.null;\n\n  // Expose imports\n  node.path = file;\n  node.dirname = dirname(file);\n  // Store the modified time\n  stat = fs.statSync(file);\n  node.mtime = stat.mtime;\n  this.paths.push(node.dirname);\n\n  if (this.options._imports) this.options._imports.push(node.clone());\n\n  // Parse the file\n  importStack.push(file);\n  nodes.filename = file;\n\n  if (literal) {\n    literal = new nodes.Literal(str.replace(/\\r\\n?/g, '\\n'));\n    literal.lineno = literal.column = 1;\n    if (!this.resolveURL) return literal;\n  }\n\n  // parse\n  var block = new nodes.Block\n    , parser = new Parser(str, utils.merge({ root: block }, this.options));\n\n  try {\n    block = parser.parse();\n  } catch (err) {\n    var line = parser.lexer.lineno\n      , column = parser.lexer.column;\n\n    if (literal && this.includeCSS && this.resolveURL) {\n      this.warn('ParseError: ' + file + ':' + line + ':' + column + '. This file included as-is');\n      return literal;\n    } else {\n      err.filename = file;\n      err.lineno = line;\n      err.column = column;\n      err.input = str;\n      throw err;\n    }\n  }\n\n  // Evaluate imported \"root\"\n  block = block.clone(this.currentBlock);\n  block.parent = this.currentBlock;\n  block.scope = false;\n  var ret = this.visit(block);\n  importStack.pop();\n  if (!this.resolveURL || this.resolveURL.nocheck) this.paths.pop();\n\n  return ret;\n}\n\n/**\n * Initialize a new `Evaluator` with the given `root` Node\n * and the following `options`.\n *\n * Options:\n *\n *   - `compress`  Compress the css output, defaults to false\n *   - `warn`  Warn the user of duplicate function definitions etc\n *\n * @param {Node} root\n * @api private\n */\n\nvar Evaluator = module.exports = function Evaluator(root, options) {\n  options = options || {};\n  Visitor.call(this, root);\n  var functions = this.functions = options.functions || {};\n  this.stack = new Stack;\n  this.imports = options.imports || [];\n  this.globals = options.globals || {};\n  this.paths = options.paths || [];\n  this.prefix = options.prefix || '';\n  this.filename = options.filename;\n  this.includeCSS = options['include css'];\n  this.resolveURL = functions.url\n    && 'resolver' == functions.url.name\n    && functions.url.options;\n  this.paths.push(dirname(options.filename || '.'));\n  this.stack.push(this.global = new Frame(root));\n  this.warnings = options.warn;\n  this.options = options;\n  this.calling = []; // TODO: remove, use stack\n  this.importStack = [];\n  this.requireHistory = {};\n  this.return = 0;\n};\n\n/**\n * Inherit from `Visitor.prototype`.\n */\n\nEvaluator.prototype.__proto__ = Visitor.prototype;\n\n/**\n * Proxy visit to expose node line numbers.\n *\n * @param {Node} node\n * @return {Node}\n * @api private\n */\n\nvar visit = Visitor.prototype.visit;\nEvaluator.prototype.visit = function(node){\n  try {\n    return visit.call(this, node);\n  } catch (err) {\n    if (err.filename) throw err;\n    err.lineno = node.lineno;\n    err.column = node.column;\n    err.filename = node.filename;\n    err.stylusStack = this.stack.toString();\n    try {\n      err.input = fs.readFileSync(err.filename, 'utf8');\n    } catch (err) {\n      // ignore\n    }\n    throw err;\n  }\n};\n\n/**\n * Perform evaluation setup:\n *\n *   - populate global scope\n *   - iterate imports\n *\n * @api private\n */\n\nEvaluator.prototype.setup = function(){\n  var root = this.root;\n  var imports = [];\n\n  this.populateGlobalScope();\n  this.imports.forEach(function(file){\n    var expr = new nodes.Expression;\n    expr.push(new nodes.String(file));\n    imports.push(new nodes.Import(expr));\n  }, this);\n\n  root.nodes = imports.concat(root.nodes);\n};\n\n/**\n * Populate the global scope with:\n *\n *   - css colors\n *   - user-defined globals\n *\n * @api private\n */\n\nEvaluator.prototype.populateGlobalScope = function(){\n  var scope = this.global.scope;\n\n  // colors\n  Object.keys(colors).forEach(function(name){\n    var color = colors[name]\n      , rgba = new nodes.RGBA(color[0], color[1], color[2], color[3])\n      , node = new nodes.Ident(name, rgba);\n    rgba.name = name;\n    scope.add(node);\n  });\n\n  // expose url function\n  scope.add(new nodes.Ident(\n    'embedurl',\n    new nodes.Function('embedurl', require('../functions/url')({\n      limit: false\n    }))\n  ));\n\n  // user-defined globals\n  var globals = this.globals;\n  Object.keys(globals).forEach(function(name){\n    var val = globals[name];\n    if (!val.nodeName) val = new nodes.Literal(val);\n    scope.add(new nodes.Ident(name, val));\n  });\n};\n\n/**\n * Evaluate the tree.\n *\n * @return {Node}\n * @api private\n */\n\nEvaluator.prototype.evaluate = function(){\n  debug('eval %s', this.filename);\n  this.setup();\n  return this.visit(this.root);\n};\n\n/**\n * Visit Group.\n */\n\nEvaluator.prototype.visitGroup = function(group){\n  group.nodes = group.nodes.map(function(selector){\n    selector.val = this.interpolate(selector);\n    debug('ruleset %s', selector.val);\n    return selector;\n  }, this);\n\n  group.block = this.visit(group.block);\n  return group;\n};\n\n/**\n * Visit Return.\n */\n\nEvaluator.prototype.visitReturn = function(ret){\n  ret.expr = this.visit(ret.expr);\n  throw ret;\n};\n\n/**\n * Visit Media.\n */\n\nEvaluator.prototype.visitMedia = function(media){\n  media.block = this.visit(media.block);\n  media.val = this.visit(media.val);\n  return media;\n};\n\n/**\n * Visit QueryList.\n */\n\nEvaluator.prototype.visitQueryList = function(queries){\n  var val, query;\n  queries.nodes.forEach(this.visit, this);\n\n  if (1 == queries.nodes.length) {\n    query = queries.nodes[0];\n    if (val = this.lookup(query.type)) {\n      val = val.first.string;\n      if (!val) return queries;\n      var Parser = require('../parser')\n        , parser = new Parser(val, this.options);\n      queries = this.visit(parser.queries());\n    }\n  }\n  return queries;\n};\n\n/**\n * Visit Query.\n */\n\nEvaluator.prototype.visitQuery = function(node){\n  node.predicate = this.visit(node.predicate);\n  node.type = this.visit(node.type);\n  node.nodes.forEach(this.visit, this);\n  return node;\n};\n\n/**\n * Visit Feature.\n */\n\nEvaluator.prototype.visitFeature = function(node){\n  node.name = this.interpolate(node);\n  if (node.expr) {\n    this.return++;\n    node.expr = this.visit(node.expr);\n    this.return--;\n  }\n  return node;\n};\n\n/**\n * Visit Object.\n */\n\nEvaluator.prototype.visitObject = function(obj){\n  for (var key in obj.vals) {\n    obj.vals[key] = this.visit(obj.vals[key]);\n  }\n  return obj;\n};\n\n/**\n * Visit Member.\n */\n\nEvaluator.prototype.visitMember = function(node){\n  var left = node.left\n    , right = node.right\n    , obj = this.visit(left).first;\n\n  if ('object' != obj.nodeName) {\n    throw new Error(left.toString() + ' has no property .' + right);\n  }\n  if (node.val) {\n    this.return++;\n    obj.set(right.name, this.visit(node.val));\n    this.return--;\n  }\n  return obj.get(right.name);\n};\n\n/**\n * Visit Keyframes.\n */\n\nEvaluator.prototype.visitKeyframes = function(keyframes){\n  var val;\n  if (keyframes.fabricated) return keyframes;\n  keyframes.val = this.interpolate(keyframes).trim();\n  if (val = this.lookup(keyframes.val)) {\n    keyframes.val = val.first.string || val.first.name;\n  }\n  keyframes.block = this.visit(keyframes.block);\n\n  if ('official' != keyframes.prefix) return keyframes;\n\n  this.vendors.forEach(function(prefix){\n    // IE never had prefixes for keyframes\n    if ('ms' == prefix) return;\n    var node = keyframes.clone();\n    node.val = keyframes.val;\n    node.prefix = prefix;\n    node.block = keyframes.block;\n    node.fabricated = true;\n    this.currentBlock.push(node);\n  }, this);\n\n  return nodes.null;\n};\n\n/**\n * Visit Function.\n */\n\nEvaluator.prototype.visitFunction = function(fn){\n  // check local\n  var local = this.stack.currentFrame.scope.lookup(fn.name);\n  if (local) this.warn('local ' + local.nodeName + ' \"' + fn.name + '\" previously defined in this scope');\n\n  // user-defined\n  var user = this.functions[fn.name];\n  if (user) this.warn('user-defined function \"' + fn.name + '\" is already defined');\n\n  // BIF\n  var bif = bifs[fn.name];\n  if (bif) this.warn('built-in function \"' + fn.name + '\" is already defined');\n\n  return fn;\n};\n\n/**\n * Visit Each.\n */\n\nEvaluator.prototype.visitEach = function(each){\n  this.return++;\n  var expr = utils.unwrap(this.visit(each.expr))\n    , len = expr.nodes.length\n    , val = new nodes.Ident(each.val)\n    , key = new nodes.Ident(each.key || '__index__')\n    , scope = this.currentScope\n    , block = this.currentBlock\n    , vals = []\n    , self = this\n    , body\n    , obj;\n  this.return--;\n\n  each.block.scope = false;\n\n  function visitBody(key, val) {\n    scope.add(val);\n    scope.add(key);\n    body = self.visit(each.block.clone());\n    vals = vals.concat(body.nodes);\n  }\n\n  // for prop in obj\n  if (1 == len && 'object' == expr.nodes[0].nodeName) {\n    obj = expr.nodes[0];\n    for (var prop in obj.vals) {\n      val.val = new nodes.String(prop);\n      key.val = obj.get(prop);\n      visitBody(key, val);\n    }\n  } else {\n    for (var i = 0; i < len; ++i) {\n      val.val = expr.nodes[i];\n      key.val = new nodes.Unit(i);\n      visitBody(key, val);\n    }\n  }\n\n  this.mixin(vals, block);\n  return vals[vals.length - 1] || nodes.null;\n};\n\n/**\n * Visit Call.\n */\n\nEvaluator.prototype.visitCall = function(call){\n  debug('call %s', call);\n  var fn = this.lookup(call.name)\n    , literal\n    , ret;\n\n  // url()\n  this.ignoreColors = 'url' == call.name;\n\n  // Variable function\n  if (fn && 'expression' == fn.nodeName) {\n    fn = fn.nodes[0];\n  }\n\n  // Not a function? try user-defined or built-ins\n  if (fn && 'function' != fn.nodeName) {\n    fn = this.lookupFunction(call.name);\n  }\n\n  // Undefined function? render literal CSS\n  if (!fn || fn.nodeName != 'function') {\n    debug('%s is undefined', call);\n    // Special case for `calc`\n    if ('calc' == this.unvendorize(call.name)) {\n      literal = call.args.nodes && call.args.nodes[0];\n      if (literal) ret = new nodes.Literal(call.name + literal);\n    } else {\n      ret = this.literalCall(call);\n    }\n    this.ignoreColors = false;\n    return ret;\n  }\n\n  this.calling.push(call.name);\n\n  // Massive stack\n  if (this.calling.length > 200) {\n    throw new RangeError('Maximum stylus call stack size exceeded');\n  }\n\n  // First node in expression\n  if ('expression' == fn.nodeName) fn = fn.first;\n\n  // Evaluate arguments\n  this.return++;\n  var args = this.visit(call.args);\n\n  for (var key in args.map) {\n    args.map[key] = this.visit(args.map[key].clone());\n  }\n  this.return--;\n\n  // Built-in\n  if (fn.fn) {\n    debug('%s is built-in', call);\n    ret = this.invokeBuiltin(fn.fn, args);\n  // User-defined\n  } else if ('function' == fn.nodeName) {\n    debug('%s is user-defined', call);\n    // Evaluate mixin block\n    if (call.block) call.block = this.visit(call.block);\n    ret = this.invokeFunction(fn, args, call.block);\n  }\n\n  this.calling.pop();\n  this.ignoreColors = false;\n  return ret;\n};\n\n/**\n * Visit Ident.\n */\n\nEvaluator.prototype.visitIdent = function(ident){\n  var prop;\n  // Property lookup\n  if (ident.property) {\n    if (prop = this.lookupProperty(ident.name)) {\n      return this.visit(prop.expr.clone());\n    }\n    return nodes.null;\n  // Lookup\n  } else if (ident.val.isNull) {\n    var val = this.lookup(ident.name);\n    // Object or Block mixin\n    if (val && ident.mixin) this.mixinNode(val);\n    return val ? this.visit(val) : ident;\n  // Assign\n  } else {\n    this.return++;\n    ident.val = this.visit(ident.val);\n    this.return--;\n    this.currentScope.add(ident);\n    return ident.val;\n  }\n};\n\n/**\n * Visit BinOp.\n */\n\nEvaluator.prototype.visitBinOp = function(binop){\n  // Special-case \"is defined\" pseudo binop\n  if ('is defined' == binop.op) return this.isDefined(binop.left);\n\n  this.return++;\n  // Visit operands\n  var op = binop.op\n    , left = this.visit(binop.left)\n    , right = ('||' == op || '&&' == op)\n      ? binop.right : this.visit(binop.right);\n\n  // HACK: ternary\n  var val = binop.val\n    ? this.visit(binop.val)\n    : null;\n  this.return--;\n\n  // Operate\n  try {\n    return this.visit(left.operate(op, right, val));\n  } catch (err) {\n    // disregard coercion issues in equality\n    // checks, and simply return false\n    if ('CoercionError' == err.name) {\n      switch (op) {\n        case '==':\n          return nodes.false;\n        case '!=':\n          return nodes.true;\n      }\n    }\n    throw err;\n  }\n};\n\n/**\n * Visit UnaryOp.\n */\n\nEvaluator.prototype.visitUnaryOp = function(unary){\n  var op = unary.op\n    , node = this.visit(unary.expr);\n\n  if ('!' != op) {\n    node = node.first.clone();\n    utils.assertType(node, 'unit');\n  }\n\n  switch (op) {\n    case '-':\n      node.val = -node.val;\n      break;\n    case '+':\n      node.val = +node.val;\n      break;\n    case '~':\n      node.val = ~node.val;\n      break;\n    case '!':\n      return node.toBoolean().negate();\n  }\n\n  return node;\n};\n\n/**\n * Visit TernaryOp.\n */\n\nEvaluator.prototype.visitTernary = function(ternary){\n  var ok = this.visit(ternary.cond).toBoolean();\n  return ok.isTrue\n    ? this.visit(ternary.trueExpr)\n    : this.visit(ternary.falseExpr);\n};\n\n/**\n * Visit Expression.\n */\n\nEvaluator.prototype.visitExpression = function(expr){\n  for (var i = 0, len = expr.nodes.length; i < len; ++i) {\n    expr.nodes[i] = this.visit(expr.nodes[i]);\n  }\n\n  // support (n * 5)px etc\n  if (this.castable(expr)) expr = this.cast(expr);\n\n  return expr;\n};\n\n/**\n * Visit Arguments.\n */\n\nEvaluator.prototype.visitArguments = Evaluator.prototype.visitExpression;\n\n/**\n * Visit Property.\n */\n\nEvaluator.prototype.visitProperty = function(prop){\n  var name = this.interpolate(prop)\n    , fn = this.lookup(name)\n    , call = fn && 'function' == fn.first.nodeName\n    , literal = ~this.calling.indexOf(name)\n    , _prop = this.property;\n\n  // Function of the same name\n  if (call && !literal && !prop.literal) {\n    var args = nodes.Arguments.fromExpression(utils.unwrap(prop.expr.clone()));\n    prop.name = name;\n    this.property = prop;\n    this.return++;\n    this.property.expr = this.visit(prop.expr);\n    this.return--;\n    var ret = this.visit(new nodes.Call(name, args));\n    this.property = _prop;\n    return ret;\n  // Regular property\n  } else {\n    this.return++;\n    prop.name = name;\n    prop.literal = true;\n    this.property = prop;\n    prop.expr = this.visit(prop.expr);\n    this.property = _prop;\n    this.return--;\n    return prop;\n  }\n};\n\n/**\n * Visit Root.\n */\n\nEvaluator.prototype.visitRoot = function(block){\n  // normalize cached imports\n  if (block != this.root) {\n    block.constructor = nodes.Block;\n    return this.visit(block);\n  }\n\n  for (var i = 0; i < block.nodes.length; ++i) {\n    block.index = i;\n    block.nodes[i] = this.visit(block.nodes[i]);\n  }\n  return block;\n};\n\n/**\n * Visit Block.\n */\n\nEvaluator.prototype.visitBlock = function(block){\n  this.stack.push(new Frame(block));\n  for (block.index = 0; block.index < block.nodes.length; ++block.index) {\n    try {\n      block.nodes[block.index] = this.visit(block.nodes[block.index]);\n    } catch (err) {\n      if ('return' == err.nodeName) {\n        if (this.return) {\n          this.stack.pop();\n          throw err;\n        } else {\n          block.nodes[block.index] = err;\n          break;\n        }\n      } else {\n        throw err;\n      }\n    }\n  }\n  this.stack.pop();\n  return block;\n};\n\n/**\n * Visit Atblock.\n */\n\nEvaluator.prototype.visitAtblock = function(atblock){\n  atblock.block = this.visit(atblock.block);\n  return atblock;\n};\n\n/**\n * Visit Atrule.\n */\n\nEvaluator.prototype.visitAtrule = function(atrule){\n  atrule.val = this.interpolate(atrule);\n  if (atrule.block) atrule.block = this.visit(atrule.block);\n  return atrule;\n};\n\n/**\n * Visit Supports.\n */\n\nEvaluator.prototype.visitSupports = function(node){\n  var condition = node.condition\n    , val;\n\n  this.return++;\n  node.condition = this.visit(condition);\n  this.return--;\n\n  val = condition.first;\n  if (1 == condition.nodes.length\n    && 'string' == val.nodeName) {\n    node.condition = val.string;\n  }\n  node.block = this.visit(node.block);\n  return node;\n};\n\n/**\n * Visit If.\n */\n\nEvaluator.prototype.visitIf = function(node){\n  var ret\n    , block = this.currentBlock\n    , negate = node.negate;\n\n  this.return++;\n  var ok = this.visit(node.cond).first.toBoolean();\n  this.return--;\n\n  node.block.scope = node.block.hasMedia;\n\n  // Evaluate body\n  if (negate) {\n    // unless\n    if (ok.isFalse) {\n      ret = this.visit(node.block);\n    }\n  } else {\n    // if\n    if (ok.isTrue) {\n      ret = this.visit(node.block);\n    // else\n    } else if (node.elses.length) {\n      var elses = node.elses\n        , len = elses.length\n        , cond;\n      for (var i = 0; i < len; ++i) {\n        // else if\n        if (elses[i].cond) {\n          elses[i].block.scope = elses[i].block.hasMedia;\n          this.return++;\n          cond = this.visit(elses[i].cond).first.toBoolean();\n          this.return--;\n          if (cond.isTrue) {\n            ret = this.visit(elses[i].block);\n            break;\n          }\n        // else\n        } else {\n          elses[i].scope = elses[i].hasMedia;\n          ret = this.visit(elses[i]);\n        }\n      }\n    }\n  }\n\n  // mixin conditional statements within\n  // a selector group or at-rule\n  if (ret && !node.postfix && block.node\n    && ~['group'\n       , 'atrule'\n       , 'media'\n       , 'supports'\n       , 'keyframes'].indexOf(block.node.nodeName)) {\n    this.mixin(ret.nodes, block);\n    return nodes.null;\n  }\n\n  return ret || nodes.null;\n};\n\n/**\n * Visit Extend.\n */\n\nEvaluator.prototype.visitExtend = function(extend){\n  var block = this.currentBlock;\n  if ('group' != block.node.nodeName) block = this.closestGroup;\n  extend.selectors.forEach(function(selector){\n    block.node.extends.push({\n      // Cloning the selector for when we are in a loop and don't want it to affect\n      // the selector nodes and cause the values to be different to expected\n      selector: this.interpolate(selector.clone()).trim(),\n      optional: selector.optional,\n      lineno: selector.lineno,\n      column: selector.column\n    });\n  }, this);\n  return nodes.null;\n};\n\n/**\n * Visit Import.\n */\n\nEvaluator.prototype.visitImport = function(imported){\n  this.return++;\n\n  var path = this.visit(imported.path).first\n    , nodeName = imported.once ? 'require' : 'import'\n    , found\n    , literal;\n\n  this.return--;\n  debug('import %s', path);\n\n  // url() passed\n  if ('url' == path.name) {\n    if (imported.once) throw new Error('You cannot @require a url');\n\n    return imported;\n  }\n\n  // Ensure string\n  if (!path.string) throw new Error('@' + nodeName + ' string expected');\n\n  var name = path = path.string;\n\n  // Absolute URL or hash\n  if (/(?:url\\s*\\(\\s*)?['\"]?(?:#|(?:https?:)?\\/\\/)/i.test(path)) {\n    if (imported.once) throw new Error('You cannot @require a url');\n    return imported;\n  }\n\n  // Literal\n  if (/\\.css(?:\"|$)/.test(path)) {\n    literal = true;\n    if (!imported.once && !this.includeCSS) {\n      return imported;\n    }\n  }\n\n  // support optional .styl\n  if (!literal && !/\\.styl$/i.test(path)) path += '.styl';\n\n  // Lookup\n  found = utils.find(path, this.paths, this.filename);\n  if (!found) {\n    found = utils.lookupIndex(name, this.paths, this.filename);\n  }\n\n  // Throw if import failed\n  if (!found) throw new Error('failed to locate @' + nodeName + ' file ' + path);\n  \n  var block = new nodes.Block;\n\n  for (var i = 0, len = found.length; i < len; ++i) {\n    block.push(importFile.call(this, imported, found[i], literal));\n  }\n\n  return block;\n};\n\n/**\n * Invoke `fn` with `args`.\n *\n * @param {Function} fn\n * @param {Array} args\n * @return {Node}\n * @api private\n */\n\nEvaluator.prototype.invokeFunction = function(fn, args, content){\n  var block = new nodes.Block(fn.block.parent);\n\n  // Clone the function body\n  // to prevent mutation of subsequent calls\n  var body = fn.block.clone(block);\n\n  // mixin block\n  var mixinBlock = this.stack.currentFrame.block;\n\n  // new block scope\n  this.stack.push(new Frame(block));\n  var scope = this.currentScope;\n\n  // normalize arguments\n  if ('arguments' != args.nodeName) {\n    var expr = new nodes.Expression;\n    expr.push(args);\n    args = nodes.Arguments.fromExpression(expr);\n  }\n\n  // arguments local\n  scope.add(new nodes.Ident('arguments', args));\n\n  // mixin scope introspection\n  scope.add(new nodes.Ident('mixin', this.return\n    ? nodes.false\n    : new nodes.String(mixinBlock.nodeName)));\n\n  // current property\n  if (this.property) {\n    var prop = this.propertyExpression(this.property, fn.name);\n    scope.add(new nodes.Ident('current-property', prop));\n  } else {\n    scope.add(new nodes.Ident('current-property', nodes.null));\n  }\n\n  // current call stack\n  var expr = new nodes.Expression;\n  for (var i = this.calling.length - 1; i-- ; ) {\n    expr.push(new nodes.Literal(this.calling[i]));\n  };\n  scope.add(new nodes.Ident('called-from', expr));\n\n  // inject arguments as locals\n  var i = 0\n    , len = args.nodes.length;\n  fn.params.nodes.forEach(function(node){\n    // rest param support\n    if (node.rest) {\n      node.val = new nodes.Expression;\n      for (; i < len; ++i) node.val.push(args.nodes[i]);\n      node.val.preserve = true;\n      node.val.isList = args.isList;\n    // argument default support\n    } else {\n      var arg = args.map[node.name] || args.nodes[i++];\n      node = node.clone();\n      if (arg) {\n        arg.isEmpty ? args.nodes[i - 1] = this.visit(node) : node.val = arg;\n      } else {\n        args.push(node.val);\n      }\n\n      // required argument not satisfied\n      if (node.val.isNull) {\n        throw new Error('argument \"' + node + '\" required for ' + fn);\n      }\n    }\n\n    scope.add(node);\n  }, this);\n\n  // mixin block\n  if (content) scope.add(new nodes.Ident('block', content, true));\n\n  // invoke\n  return this.invoke(body, true, fn.filename);\n};\n\n/**\n * Invoke built-in `fn` with `args`.\n *\n * @param {Function} fn\n * @param {Array} args\n * @return {Node}\n * @api private\n */\n\nEvaluator.prototype.invokeBuiltin = function(fn, args){\n  // Map arguments to first node\n  // providing a nicer js api for\n  // BIFs. Functions may specify that\n  // they wish to accept full expressions\n  // via .raw\n  if (fn.raw) {\n    args = args.nodes;\n  } else {\n    args = utils.params(fn).reduce(function(ret, param){\n      var arg = args.map[param] || args.nodes.shift()\n      if (arg) {\n        arg = utils.unwrap(arg);\n        var len = arg.nodes.length;\n        if (len > 1) {\n          for (var i = 0; i < len; ++i) {\n            ret.push(utils.unwrap(arg.nodes[i].first));\n          }\n        } else {\n          ret.push(arg.first);\n        }\n      }\n      return ret;\n    }, []);\n  }\n\n  // Invoke the BIF\n  var body = utils.coerce(fn.apply(this, args));\n\n  // Always wrapping allows js functions\n  // to return several values with a single\n  // Expression node\n  var expr = new nodes.Expression;\n  expr.push(body);\n  body = expr;\n\n  // Invoke\n  return this.invoke(body);\n};\n\n/**\n * Invoke the given function `body`.\n *\n * @param {Block} body\n * @return {Node}\n * @api private\n */\n\nEvaluator.prototype.invoke = function(body, stack, filename){\n  var self = this\n    , ret;\n\n  if (filename) this.paths.push(dirname(filename));\n\n  // Return\n  if (this.return) {\n    ret = this.eval(body.nodes);\n    if (stack) this.stack.pop();\n  // Mixin\n  } else {\n    body = this.visit(body);\n    if (stack) this.stack.pop();\n    this.mixin(body.nodes, this.currentBlock);\n    ret = nodes.null;\n  }\n\n  if (filename) this.paths.pop();\n\n  return ret;\n};\n\n/**\n * Mixin the given `nodes` to the given `block`.\n *\n * @param {Array} nodes\n * @param {Block} block\n * @api private\n */\n\nEvaluator.prototype.mixin = function(nodes, block){\n  if (!nodes.length) return;\n  var len = block.nodes.length\n    , head = block.nodes.slice(0, block.index)\n    , tail = block.nodes.slice(block.index + 1, len);\n  this._mixin(nodes, head, block);\n  block.index = 0;\n  block.nodes = head.concat(tail);\n};\n\n/**\n * Mixin the given `items` to the `dest` array.\n *\n * @param {Array} items\n * @param {Array} dest\n * @param {Block} block\n * @api private\n */\n\nEvaluator.prototype._mixin = function(items, dest, block){\n  var node\n    , len = items.length;\n  for (var i = 0; i < len; ++i) {\n    switch ((node = items[i]).nodeName) {\n      case 'return':\n        return;\n      case 'block':\n        this._mixin(node.nodes, dest, block);\n        break;\n      case 'media':\n        // fix link to the parent block\n        var parentNode = node.block.parent.node;\n        if (parentNode && 'call' != parentNode.nodeName) {\n          node.block.parent = block;\n        }\n      case 'property':\n        var val = node.expr;\n        // prevent `block` mixin recursion\n        if (node.literal && 'block' == val.first.name) {\n          val = utils.unwrap(val);\n          val.nodes[0] = new nodes.Literal('block');\n        }\n      default:\n        dest.push(node);\n    }\n  }\n};\n\n/**\n * Mixin the given `node` to the current block.\n *\n * @param {Node} node\n * @api private\n */\n\nEvaluator.prototype.mixinNode = function(node){\n  node = this.visit(node.first);\n  switch (node.nodeName) {\n    case 'object':\n      this.mixinObject(node);\n      return nodes.null;\n    case 'block':\n    case 'atblock':\n      this.mixin(node.nodes, this.currentBlock);\n      return nodes.null;\n  }\n};\n\n/**\n * Mixin the given `object` to the current block.\n *\n * @param {Object} object\n * @api private\n */\n\nEvaluator.prototype.mixinObject = function(object){\n  var Parser = require('../parser')\n    , root = this.root\n    , str = '$block ' + object.toBlock()\n    , parser = new Parser(str, utils.merge({ root: block }, this.options))\n    , block;\n\n  try {\n    block = parser.parse();\n  } catch (err) {\n    err.filename = this.filename;\n    err.lineno = parser.lexer.lineno;\n    err.column = parser.lexer.column;\n    err.input = str;\n    throw err;\n  }\n\n  block.parent = root;\n  block.scope = false;\n  var ret = this.visit(block)\n    , vals = ret.first.nodes;\n  for (var i = 0, len = vals.length; i < len; ++i) {\n    if (vals[i].block) {\n      this.mixin(vals[i].block.nodes, this.currentBlock);\n      break;\n    }\n  }\n};\n\n/**\n * Evaluate the given `vals`.\n *\n * @param {Array} vals\n * @return {Node}\n * @api private\n */\n\nEvaluator.prototype.eval = function(vals){\n  if (!vals) return nodes.null;\n  var len = vals.length\n    , node = nodes.null;\n\n  try {\n    for (var i = 0; i < len; ++i) {\n      node = vals[i];\n      switch (node.nodeName) {\n        case 'if':\n          if ('block' != node.block.nodeName) {\n            node = this.visit(node);\n            break;\n          }\n        case 'each':\n        case 'block':\n          node = this.visit(node);\n          if (node.nodes) node = this.eval(node.nodes);\n          break;\n        default:\n          node = this.visit(node);\n      }\n    }\n  } catch (err) {\n    if ('return' == err.nodeName) {\n      return err.expr;\n    } else {\n      throw err;\n    }\n  }\n\n  return node;\n};\n\n/**\n * Literal function `call`.\n *\n * @param {Call} call\n * @return {call}\n * @api private\n */\n\nEvaluator.prototype.literalCall = function(call){\n  call.args = this.visit(call.args);\n  return call;\n};\n\n/**\n * Lookup property `name`.\n *\n * @param {String} name\n * @return {Property}\n * @api private\n */\n\nEvaluator.prototype.lookupProperty = function(name){\n  var i = this.stack.length\n    , index = this.currentBlock.index\n    , top = i\n    , nodes\n    , block\n    , len\n    , other;\n\n  while (i--) {\n    block = this.stack[i].block;\n    if (!block.node) continue;\n    switch (block.node.nodeName) {\n      case 'group':\n      case 'function':\n      case 'if':\n      case 'each':\n      case 'atrule':\n      case 'media':\n      case 'atblock':\n      case 'call':\n        nodes = block.nodes;\n        // scan siblings from the property index up\n        if (i + 1 == top) {\n          while (index--) {\n            // ignore current property\n            if (this.property == nodes[index]) continue;\n            other = this.interpolate(nodes[index]);\n            if (name == other) return nodes[index].clone();\n          }\n        // sequential lookup for non-siblings (for now)\n        } else {\n          len = nodes.length;\n          while (len--) {\n            if ('property' != nodes[len].nodeName\n              || this.property == nodes[len]) continue;\n            other = this.interpolate(nodes[len]);\n            if (name == other) return nodes[len].clone();\n          }\n        }\n        break;\n    }\n  }\n\n  return nodes.null;\n};\n\n/**\n * Return the closest mixin-able `Block`.\n *\n * @return {Block}\n * @api private\n */\n\nEvaluator.prototype.__defineGetter__('closestBlock', function(){\n  var i = this.stack.length\n    , block;\n  while (i--) {\n    block = this.stack[i].block;\n    if (block.node) {\n      switch (block.node.nodeName) {\n        case 'group':\n        case 'keyframes':\n        case 'atrule':\n        case 'atblock':\n        case 'media':\n        case 'call':\n          return block;\n      }\n    }\n  }\n});\n\n/**\n * Return the closest group block.\n *\n * @return {Block}\n * @api private\n */\n\nEvaluator.prototype.__defineGetter__('closestGroup', function(){\n  var i = this.stack.length\n    , block;\n  while (i--) {\n    block = this.stack[i].block;\n    if (block.node && 'group' == block.node.nodeName) {\n      return block;\n    }\n  }\n});\n\n/**\n * Return the current selectors stack.\n *\n * @return {Array}\n * @api private\n */\n\nEvaluator.prototype.__defineGetter__('selectorStack', function(){\n  var block\n    , stack = [];\n  for (var i = 0, len = this.stack.length; i < len; ++i) {\n    block = this.stack[i].block;\n    if (block.node && 'group' == block.node.nodeName) {\n      block.node.nodes.forEach(function(selector) {\n        if (!selector.val) selector.val = this.interpolate(selector);\n      }, this);\n      stack.push(block.node.nodes);\n    }\n  }\n  return stack;\n});\n\n/**\n * Lookup `name`, with support for JavaScript\n * functions, and BIFs.\n *\n * @param {String} name\n * @return {Node}\n * @api private\n */\n\nEvaluator.prototype.lookup = function(name){\n  var val;\n  if (this.ignoreColors && name in colors) return;\n  if (val = this.stack.lookup(name)) {\n    return utils.unwrap(val);\n  } else {\n    return this.lookupFunction(name);\n  }\n};\n\n/**\n * Map segments in `node` returning a string.\n *\n * @param {Node} node\n * @return {String}\n * @api private\n */\n\nEvaluator.prototype.interpolate = function(node){\n  var self = this\n    , isSelector = ('selector' == node.nodeName);\n  function toString(node) {\n    switch (node.nodeName) {\n      case 'function':\n      case 'ident':\n        return node.name;\n      case 'literal':\n      case 'string':\n        if (self.prefix && !node.prefixed && !node.val.nodeName) {\n          node.val = node.val.replace(/\\./g, '.' + self.prefix);\n          node.prefixed = true;\n        }\n        return node.val;\n      case 'unit':\n        // Interpolation inside keyframes\n        return '%' == node.type ? node.val + '%' : node.val;\n      case 'member':\n        return toString(self.visit(node));\n      case 'expression':\n        // Prevent cyclic `selector()` calls.\n        if (self.calling && ~self.calling.indexOf('selector') && self._selector) return self._selector;\n        self.return++;\n        var ret = toString(self.visit(node).first);\n        self.return--;\n        if (isSelector) self._selector = ret;\n        return ret;\n    }\n  }\n\n  if (node.segments) {\n    return node.segments.map(toString).join('');\n  } else {\n    return toString(node);\n  }\n};\n\n/**\n * Lookup JavaScript user-defined or built-in function.\n *\n * @param {String} name\n * @return {Function}\n * @api private\n */\n\nEvaluator.prototype.lookupFunction = function(name){\n  var fn = this.functions[name] || bifs[name];\n  if (fn) return new nodes.Function(name, fn);\n};\n\n/**\n * Check if the given `node` is an ident, and if it is defined.\n *\n * @param {Node} node\n * @return {Boolean}\n * @api private\n */\n\nEvaluator.prototype.isDefined = function(node){\n  if ('ident' == node.nodeName) {\n    return nodes.Boolean(this.lookup(node.name));\n  } else {\n    throw new Error('invalid \"is defined\" check on non-variable ' + node);\n  }\n};\n\n/**\n * Return `Expression` based on the given `prop`,\n * replacing cyclic calls to the given function `name`\n * with \"__CALL__\".\n *\n * @param {Property} prop\n * @param {String} name\n * @return {Expression}\n * @api private\n */\n\nEvaluator.prototype.propertyExpression = function(prop, name){\n  var expr = new nodes.Expression\n    , val = prop.expr.clone();\n\n  // name\n  expr.push(new nodes.String(prop.name));\n\n  // replace cyclic call with __CALL__\n  function replace(node) {\n    if ('call' == node.nodeName && name == node.name) {\n      return new nodes.Literal('__CALL__');\n    }\n\n    if (node.nodes) node.nodes = node.nodes.map(replace);\n    return node;\n  }\n\n  replace(val);\n  expr.push(val);\n  return expr;\n};\n\n/**\n * Cast `expr` to the trailing ident.\n *\n * @param {Expression} expr\n * @return {Unit}\n * @api private\n */\n\nEvaluator.prototype.cast = function(expr){\n  return new nodes.Unit(expr.first.val, expr.nodes[1].name);\n};\n\n/**\n * Check if `expr` is castable.\n *\n * @param {Expression} expr\n * @return {Boolean}\n * @api private\n */\n\nEvaluator.prototype.castable = function(expr){\n  return 2 == expr.nodes.length\n    && 'unit' == expr.first.nodeName\n    && ~units.indexOf(expr.nodes[1].name);\n};\n\n/**\n * Warn with the given `msg`.\n *\n * @param {String} msg\n * @api private\n */\n\nEvaluator.prototype.warn = function(msg){\n  if (!this.warnings) return;\n  console.warn('\\u001b[33mWarning:\\u001b[0m ' + msg);\n};\n\n/**\n * Return the current `Block`.\n *\n * @return {Block}\n * @api private\n */\n\nEvaluator.prototype.__defineGetter__('currentBlock', function(){\n  return this.stack.currentFrame.block;\n});\n\n/**\n * Return an array of vendor names.\n *\n * @return {Array}\n * @api private\n */\n\nEvaluator.prototype.__defineGetter__('vendors', function(){\n  return this.lookup('vendors').nodes.map(function(node){\n    return node.string;\n  });\n});\n\n/**\n * Return the property name without vendor prefix.\n *\n * @param {String} prop\n * @return {String}\n * @api public\n */\n\nEvaluator.prototype.unvendorize = function(prop){\n  for (var i = 0, len = this.vendors.length; i < len; i++) {\n    if ('official' != this.vendors[i]) {\n      var vendor = '-' + this.vendors[i] + '-';\n      if (~prop.indexOf(vendor)) return prop.replace(vendor, '');\n    }\n  }\n  return prop;\n};\n\n/**\n * Return the current frame `Scope`.\n *\n * @return {Scope}\n * @api private\n */\n\nEvaluator.prototype.__defineGetter__('currentScope', function(){\n  return this.stack.currentFrame.scope;\n});\n\n/**\n * Return the current `Frame`.\n *\n * @return {Frame}\n * @api private\n */\n\nEvaluator.prototype.__defineGetter__('currentFrame', function(){\n  return this.stack.currentFrame;\n});\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/visitor/index.js":"\n/*!\n * Stylus - Visitor\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Initialize a new `Visitor` with the given `root` Node.\n *\n * @param {Node} root\n * @api private\n */\n\nvar Visitor = module.exports = function Visitor(root) {\n  this.root = root;\n};\n\n/**\n * Visit the given `node`.\n *\n * @param {Node|Array} node\n * @api public\n */\n\nVisitor.prototype.visit = function(node, fn){\n  var method = 'visit' + node.constructor.name;\n  if (this[method]) return this[method](node);\n  return node;\n};\n\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/units.js":"\n/*!\n * Stylus - units\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n// units found in http://www.w3.org/TR/css3-values\n\nmodule.exports = [\n    'em', 'ex', 'ch', 'rem' // relative lengths\n  , 'vw', 'vh', 'vmin', 'vmax' // relative viewport-percentage lengths\n  , 'cm', 'mm', 'in', 'pt', 'pc', 'px' // absolute lengths\n  , 'deg', 'grad', 'rad', 'turn' // angles\n  , 's', 'ms' // times\n  , 'Hz', 'kHz' // frequencies\n  , 'dpi', 'dpcm', 'dppx', 'x' // resolutions\n  , '%' // percentage type\n  , 'fr' // grid-layout (http://www.w3.org/TR/css3-grid-layout/)\n];\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/stack/index.js":"\n/*!\n * Stylus - Stack\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Initialize a new `Stack`.\n *\n * @api private\n */\n\nvar Stack = module.exports = function Stack() {\n  Array.apply(this, arguments);\n};\n\n/**\n * Inherit from `Array.prototype`.\n */\n\nStack.prototype.__proto__ = Array.prototype;\n\n/**\n * Push the given `frame`.\n *\n * @param {Frame} frame\n * @api public\n */\n\nStack.prototype.push = function(frame){\n  frame.stack = this;\n  frame.parent = this.currentFrame;\n  return [].push.apply(this, arguments);\n};\n\n/**\n * Return the current stack `Frame`.\n *\n * @return {Frame}\n * @api private\n */\n\nStack.prototype.__defineGetter__('currentFrame', function(){\n  return this[this.length - 1];\n});\n\n/**\n * Lookup stack frame for the given `block`.\n *\n * @param {Block} block\n * @return {Frame}\n * @api private\n */\n\nStack.prototype.getBlockFrame = function(block){\n  for (var i = 0; i < this.length; ++i) {\n    if (block == this[i].block) {\n      return this[i];\n    }\n  }\n};\n\n/**\n * Lookup the given local variable `name`, relative\n * to the lexical scope of the current frame's `Block`.\n *\n * When the result of a lookup is an identifier\n * a recursive lookup is performed, defaulting to\n * returning the identifier itself.\n *\n * @param {String} name\n * @return {Node}\n * @api private\n */\n\nStack.prototype.lookup = function(name){\n  var block = this.currentFrame.block\n    , val\n    , ret;\n\n  do {\n    var frame = this.getBlockFrame(block);\n    if (frame && (val = frame.lookup(name))) {\n      return val;\n    }\n  } while (block = block.parent);\n};\n\n/**\n * Custom inspect.\n *\n * @return {String}\n * @api private\n */\n\nStack.prototype.inspect = function(){\n  return this.reverse().map(function(frame){\n    return frame.inspect();\n  }).join('\\n');\n};\n\n/**\n * Return stack string formatted as:\n *\n *   at <context> (<filename>:<lineno>:<column>)\n *\n * @return {String}\n * @api private\n */\n\nStack.prototype.toString = function(){\n  var block\n    , node\n    , buf = []\n    , location\n    , len = this.length;\n\n  while (len--) {\n    block = this[len].block;\n    if (node = block.node) {\n      location = '(' + node.filename + ':' + (node.lineno + 1) + ':' + node.column + ')';\n      switch (node.nodeName) {\n        case 'function':\n          buf.push('    at ' + node.name + '() ' + location);\n          break;\n        case 'group':\n          buf.push('    at \"' + node.nodes[0].val + '\" ' + location);\n          break;\n      }\n    }\n  }\n\n  return buf.join('\\n');\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/stack/frame.js":"\n/*!\n * Stylus - stack - Frame\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Scope = require('./scope');\n\n/**\n * Initialize a new `Frame` with the given `block`.\n *\n * @param {Block} block\n * @api private\n */\n\nvar Frame = module.exports = function Frame(block) {\n  this._scope = false === block.scope\n    ? null\n    : new Scope;\n  this.block = block;\n};\n\n/**\n * Return this frame's scope or the parent scope\n * for scope-less blocks.\n *\n * @return {Scope}\n * @api public\n */\n\nFrame.prototype.__defineGetter__('scope', function(){\n  return this._scope || this.parent.scope;\n});\n\n/**\n * Lookup the given local variable `name`.\n *\n * @param {String} name\n * @return {Node}\n * @api private\n */\n\nFrame.prototype.lookup = function(name){\n  return this.scope.lookup(name)\n};\n\n/**\n * Custom inspect.\n *\n * @return {String}\n * @api public\n */\n\nFrame.prototype.inspect = function(){\n  return '[Frame '\n    + (false === this.block.scope\n        ? 'scope-less'\n        : this.scope.inspect())\n    + ']';\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/stack/scope.js":"\n/*!\n * Stylus - stack - Scope\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Initialize a new `Scope`.\n *\n * @api private\n */\n\nvar Scope = module.exports = function Scope() {\n  this.locals = {};\n};\n\n/**\n * Add `ident` node to the current scope.\n *\n * @param {Ident} ident\n * @api private\n */\n\nScope.prototype.add = function(ident){\n  this.locals[ident.name] = ident.val;\n};\n\n/**\n * Lookup the given local variable `name`.\n *\n * @param {String} name\n * @return {Node}\n * @api private\n */\n\nScope.prototype.lookup = function(name){\n  return this.locals[name];\n};\n\n/**\n * Custom inspect.\n *\n * @return {String}\n * @api public\n */\n\nScope.prototype.inspect = function(){\n  var keys = Object.keys(this.locals).map(function(key){ return '@' + key; });\n  return '[Scope'\n    + (keys.length ? ' ' + keys.join(', ') : '')\n    + ']';\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/utils.js":"\n/*!\n * Stylus - utils\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar nodes = require('./nodes')\n  , basename = require('path').basename\n  , relative = require('path').relative\n  , join = require('path').join\n  , isAbsolute = require('path').isAbsolute\n  , glob = require('glob')\n  , fs = require('fs');\n\n/**\n * Check if `path` looks absolute.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nexports.absolute = isAbsolute || function(path){\n  // On Windows the path could start with a drive letter, i.e. a:\\\\ or two leading backslashes.\n  // Also on Windows, the path may have been normalized to forward slashes, so check for this too.\n  return path.substr(0, 2) == '\\\\\\\\' || '/' === path.charAt(0) || /^[a-z]:[\\\\\\/]/i.test(path);\n};\n\n/**\n * Attempt to lookup `path` within `paths` from tail to head.\n * Optionally a path to `ignore` may be passed.\n *\n * @param {String} path\n * @param {String} paths\n * @param {String} ignore\n * @return {String}\n * @api private\n */\n\nexports.lookup = function(path, paths, ignore){\n  var lookup\n    , i = paths.length;\n\n  // Absolute\n  if (exports.absolute(path)) {\n    try {\n      fs.statSync(path);\n      return path;\n    } catch (err) {\n      // Ignore, continue on\n      // to trying relative lookup.\n      // Needed for url(/images/foo.png)\n      // for example\n    }\n  }\n\n  // Relative\n  while (i--) {\n    try {\n      lookup = join(paths[i], path);\n      if (ignore == lookup) continue;\n      fs.statSync(lookup);\n      return lookup;\n    } catch (err) {\n      // Ignore\n    }\n  }\n};\n\n/**\n * Like `utils.lookup` but uses `glob` to find files.\n *\n * @param {String} path\n * @param {String} paths\n * @param {String} ignore\n * @return {Array}\n * @api private\n */\nexports.find = function(path, paths, ignore) {\n  var lookup\n    , found\n    , i = paths.length;\n\n  // Absolute\n  if (exports.absolute(path)) {\n    if ((found = glob.sync(path)).length) {\n      return found;\n    }\n  }\n\n  // Relative\n  while (i--) {\n    lookup = join(paths[i], path);\n    if (ignore == lookup) continue;\n    if ((found = glob.sync(lookup)).length) {\n      return found;\n    }\n  }\n};\n\n/**\n * Lookup index file inside dir with given `name`.\n *\n * @param {String} name\n * @return {Array}\n * @api private\n */\n\nexports.lookupIndex = function(name, paths, filename){\n  // foo/index.styl\n  var found = exports.find(join(name, 'index.styl'), paths, filename);\n  if (!found) {\n    // foo/foo.styl\n    found = exports.find(join(name, basename(name).replace(/\\.styl/i, '') + '.styl'), paths, filename);\n  }\n  if (!found && !~name.indexOf('node_modules')) {\n    // node_modules/foo/.. or node_modules/foo.styl/..\n    found = lookupPackage(join('node_modules', name));\n  }\n  return found;\n\n  function lookupPackage(dir) {\n    var pkg = exports.lookup(join(dir, 'package.json'), paths, filename);\n    if (!pkg) {\n      return /\\.styl$/i.test(dir) ? exports.lookupIndex(dir, paths, filename) : lookupPackage(dir + '.styl');\n    }\n    var main = require(relative(__dirname, pkg)).main;\n    if (main) {\n      found = exports.find(join(dir, main), paths, filename);\n    } else {\n      found = exports.lookupIndex(dir, paths, filename);\n    }\n    return found;\n  }\n};\n\n/**\n * Format the given `err` with the given `options`.\n *\n * Options:\n *\n *   - `filename`   context filename\n *   - `context`    context line count [8]\n *   - `lineno`     context line number\n *   - `column`     context column number\n *   - `input`        input string\n *\n * @param {Error} err\n * @param {Object} options\n * @return {Error}\n * @api private\n */\n\nexports.formatException = function(err, options){\n  var lineno = options.lineno\n    , column = options.column\n    , filename = options.filename\n    , str = options.input\n    , context = options.context || 8\n    , context = context / 2\n    , lines = ('\\n' + str).split('\\n')\n    , start = Math.max(lineno - context, 1)\n    , end = Math.min(lines.length, lineno + context)\n    , pad = end.toString().length;\n\n  var context = lines.slice(start, end).map(function(line, i){\n    var curr = i + start;\n    return '   '\n      + Array(pad - curr.toString().length + 1).join(' ')\n      + curr\n      + '| '\n      + line\n      + (curr == lineno\n        ? '\\n' + Array(curr.toString().length + 5 + column).join('-') + '^'\n        : '');\n  }).join('\\n');\n\n  err.message = filename\n    + ':' + lineno\n    + ':' + column\n    + '\\n' + context\n    + '\\n\\n' + err.message + '\\n'\n    + (err.stylusStack ? err.stylusStack + '\\n' : '');\n\n  // Don't show JS stack trace for Stylus errors\n  if (err.fromStylus) err.stack = 'Error: ' + err.message;\n\n  return err;\n};\n\n/**\n * Assert that `node` is of the given `type`, or throw.\n *\n * @param {Node} node\n * @param {Function} type\n * @param {String} param\n * @api public\n */\n\nexports.assertType = function(node, type, param){\n  exports.assertPresent(node, param);\n  if (node.nodeName == type) return;\n  var actual = node.nodeName\n    , msg = 'expected '\n      + (param ? '\"' + param + '\" to be a ' :  '')\n      + type + ', but got '\n      + actual + ':' + node;\n  throw new Error('TypeError: ' + msg);\n};\n\n/**\n * Assert that `node` is a `String` or `Ident`.\n *\n * @param {Node} node\n * @param {String} param\n * @api public\n */\n\nexports.assertString = function(node, param){\n  exports.assertPresent(node, param);\n  switch (node.nodeName) {\n    case 'string':\n    case 'ident':\n    case 'literal':\n      return;\n    default:\n      var actual = node.nodeName\n        , msg = 'expected string, ident or literal, but got ' + actual + ':' + node;\n      throw new Error('TypeError: ' + msg);\n  }\n};\n\n/**\n * Assert that `node` is a `RGBA` or `HSLA`.\n *\n * @param {Node} node\n * @param {String} param\n * @api public\n */\n\nexports.assertColor = function(node, param){\n  exports.assertPresent(node, param);\n  switch (node.nodeName) {\n    case 'rgba':\n    case 'hsla':\n      return;\n    default:\n      var actual = node.nodeName\n        , msg = 'expected rgba or hsla, but got ' + actual + ':' + node;\n      throw new Error('TypeError: ' + msg);\n  }\n};\n\n/**\n * Assert that param `name` is given, aka the `node` is passed.\n *\n * @param {Node} node\n * @param {String} name\n * @api public\n */\n\nexports.assertPresent = function(node, name){\n  if (node) return;\n  if (name) throw new Error('\"' + name + '\" argument required');\n  throw new Error('argument missing');\n};\n\n/**\n * Unwrap `expr`.\n *\n * Takes an expressions with length of 1\n * such as `((1 2 3))` and unwraps it to `(1 2 3)`.\n *\n * @param {Expression} expr\n * @return {Node}\n * @api public\n */\n\nexports.unwrap = function(expr){\n  // explicitly preserve the expression\n  if (expr.preserve) return expr;\n  if ('arguments' != expr.nodeName && 'expression' != expr.nodeName) return expr;\n  if (1 != expr.nodes.length) return expr;\n  if ('arguments' != expr.nodes[0].nodeName && 'expression' != expr.nodes[0].nodeName) return expr;\n  return exports.unwrap(expr.nodes[0]);\n};\n\n/**\n * Coerce JavaScript values to their Stylus equivalents.\n *\n * @param {Mixed} val\n * @param {Boolean} [raw]\n * @return {Node}\n * @api public\n */\n\nexports.coerce = function(val, raw){\n  switch (typeof val) {\n    case 'function':\n      return val;\n    case 'string':\n      return new nodes.String(val);\n    case 'boolean':\n      return new nodes.Boolean(val);\n    case 'number':\n      return new nodes.Unit(val);\n    default:\n      if (null == val) return nodes.null;\n      if (Array.isArray(val)) return exports.coerceArray(val, raw);\n      if (val.nodeName) return val;\n      return exports.coerceObject(val, raw);\n  }\n};\n\n/**\n * Coerce a javascript `Array` to a Stylus `Expression`.\n *\n * @param {Array} val\n * @param {Boolean} [raw]\n * @return {Expression}\n * @api private\n */\n\nexports.coerceArray = function(val, raw){\n  var expr = new nodes.Expression;\n  val.forEach(function(val){\n    expr.push(exports.coerce(val, raw));\n  });\n  return expr;\n};\n\n/**\n * Coerce a javascript object to a Stylus `Expression` or `Object`.\n *\n * For example `{ foo: 'bar', bar: 'baz' }` would become\n * the expression `(foo 'bar') (bar 'baz')`. If `raw` is true\n * given `obj` would become a Stylus hash object.\n *\n * @param {Object} obj\n * @param {Boolean} [raw]\n * @return {Expression|Object}\n * @api public\n */\n\nexports.coerceObject = function(obj, raw){\n  var node = raw ? new nodes.Object : new nodes.Expression\n    , val;\n\n  for (var key in obj) {\n    val = exports.coerce(obj[key], raw);\n    key = new nodes.Ident(key);\n    if (raw) {\n      node.set(key, val);\n    } else {\n      node.push(exports.coerceArray([key, val]));\n    }\n  }\n\n  return node;\n};\n\n/**\n * Return param names for `fn`.\n *\n * @param {Function} fn\n * @return {Array}\n * @api private\n */\n\nexports.params = function(fn){\n  return fn\n    .toString()\n    .match(/\\(([^)]*)\\)/)[1].split(/ *, */);\n};\n\n/**\n * Merge object `b` with `a`.\n *\n * @param {Object} a\n * @param {Object} b\n * @param {Boolean} [deep]\n * @return {Object} a\n * @api private\n */\nexports.merge = function(a, b, deep) {\n  for (var k in b) {\n    if (deep && a[k]) {\n      var nodeA = exports.unwrap(a[k]).first\n        , nodeB = exports.unwrap(b[k]).first;\n\n      if ('object' == nodeA.nodeName && 'object' == nodeB.nodeName) {\n        a[k].first.vals = exports.merge(nodeA.vals, nodeB.vals, deep);\n      } else {\n        a[k] = b[k];\n      }\n    } else {\n      a[k] = b[k];\n    }\n  }\n  return a;\n};\n\n/**\n * Returns an array with unique values.\n *\n * @param {Array} arr\n * @return {Array}\n * @api private\n */\n\nexports.uniq = function(arr){\n  var obj = {}\n    , ret = [];\n\n  for (var i = 0, len = arr.length; i < len; ++i) {\n    if (arr[i] in obj) continue;\n\n    obj[arr[i]] = true;\n    ret.push(arr[i]);\n  }\n  return ret;\n};\n\n/**\n * Compile selector strings in `arr` from the bottom-up\n * to produce the selector combinations. For example\n * the following Stylus:\n *\n *    ul\n *      li\n *      p\n *        a\n *          color: red\n *\n * Would return:\n *\n *      [ 'ul li a', 'ul p a' ]\n *\n * @param {Array} arr\n * @param {Boolean} leaveHidden\n * @return {Array}\n * @api private\n */\n\nexports.compileSelectors = function(arr, leaveHidden){\n  var selectors = []\n    , Parser = require('./selector-parser')\n    , indent = (this.indent || '')\n    , buf = [];\n\n  function parse(selector, buf) {\n    var parts = [selector.val]\n      , str = new Parser(parts[0], parents, parts).parse().val\n      , parents = [];\n\n    if (buf.length) {\n      for (var i = 0, len = buf.length; i < len; ++i) {\n        parts.push(buf[i]);\n        parents.push(str);\n        var child = new Parser(buf[i], parents, parts).parse();\n\n        if (child.nested) {\n          str += ' ' + child.val;\n        } else {\n          str = child.val;\n        }\n      }\n    }\n    return str.trim();\n  }\n\n  function compile(arr, i) {\n    if (i) {\n      arr[i].forEach(function(selector){\n        if (!leaveHidden && selector.isPlaceholder) return;\n        if (selector.inherits) {\n          buf.unshift(selector.val);\n          compile(arr, i - 1);\n          buf.shift();\n        } else {\n          selectors.push(indent + parse(selector, buf));\n        }\n      });\n    } else {\n      arr[0].forEach(function(selector){\n        if (!leaveHidden && selector.isPlaceholder) return;\n        var str = parse(selector, buf);\n        if (str) selectors.push(indent + str);\n      });\n    }\n  }\n\n  compile(arr, arr.length - 1);\n\n  // Return the list with unique selectors only\n  return exports.uniq(selectors);\n};\n\n/**\n * Attempt to parse string.\n *\n * @param {String} str\n * @return {Node}\n * @api private\n */\n\nexports.parseString = function(str){\n  var Parser = require('./parser')\n    , parser\n    , ret;\n\n  try {\n    parser = new Parser(str);\n    parser.state.push('expression');\n    ret = new nodes.Expression();\n    ret.nodes = parser.parse().nodes;\n  } catch (e) {\n    ret = new nodes.Literal(str);\n  }\n  return ret;\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/index.js":"\n/*!\n * Stylus - Evaluator - built-in functions\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\nexports['add-property'] = require('./add-property');\nexports.adjust = require('./adjust');\nexports.alpha = require('./alpha');\nexports['base-convert'] = require('./base-convert');\nexports.basename = require('./basename');\nexports.blend = require('./blend');\nexports.blue = require('./blue');\nexports.clone = require('./clone');\nexports.component = require('./component');\nexports.contrast = require('./contrast');\nexports.convert = require('./convert');\nexports['current-media'] = require('./current-media');\nexports.define = require('./define');\nexports.dirname = require('./dirname');\nexports.error = require('./error');\nexports.extname = require('./extname');\nexports.green = require('./green');\nexports.hsl = require('./hsl');\nexports.hsla = require('./hsla');\nexports.hue = require('./hue');\nexports['image-size'] = require('./image-size');\nexports.json = require('./json');\nexports.length = require('./length');\nexports.lightness = require('./lightness');\nexports['list-separator'] = require('./list-separator');\nexports.lookup = require('./lookup');\nexports.luminosity = require('./luminosity');\nexports.match = require('./match');\nexports.math = require('./math');\nexports.merge = exports.extend = require('./merge');\nexports.operate = require('./operate');\nexports['opposite-position'] = require('./opposite-position');\nexports.p = require('./p');\nexports.pathjoin = require('./pathjoin');\nexports.pop = require('./pop');\nexports.push = exports.append = require('./push');\nexports.range = require('./range');\nexports.red = require('./red');\nexports.remove = require('./remove');\nexports.replace = require('./replace');\nexports.rgb = require('./rgb');\nexports.rgba = require('./rgba');\nexports.s = require('./s');\nexports.saturation = require('./saturation');\nexports['selector-exists'] = require('./selector-exists');\nexports.selector = require('./selector');\nexports.selectors = require('./selectors');\nexports.shift = require('./shift');\nexports.split = require('./split');\nexports.substr = require('./substr');\nexports.slice = require('./slice');\nexports.tan = require('./tan');\nexports.trace = require('./trace');\nexports.transparentify = require('./transparentify');\nexports.type = exports.typeof = exports['type-of'] = require('./type');\nexports.unit = require('./unit');\nexports.unquote = require('./unquote');\nexports.unshift = exports.prepend = require('./unshift');\nexports.use = require('./use');\nexports.warn = require('./warn');\nexports['-math-prop'] = require('./math-prop');\nexports['-prefix-classes'] = require('./prefix-classes');\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/add-property.js":"var utils = require('../utils')\n  , nodes = require('../nodes');\n\n/**\n * Add property `name` with the given `expr`\n * to the mixin-able block.\n *\n * @param {String|Ident|Literal} name\n * @param {Expression} expr\n * @return {Property}\n * @api public\n */\n\n(module.exports = function addProperty(name, expr){\n  utils.assertType(name, 'expression', 'name');\n  name = utils.unwrap(name).first;\n  utils.assertString(name, 'name');\n  utils.assertType(expr, 'expression', 'expr');\n  var prop = new nodes.Property([name], expr);\n  var block = this.closestBlock;\n\n  var len = block.nodes.length\n    , head = block.nodes.slice(0, block.index)\n    , tail = block.nodes.slice(block.index++, len);\n  head.push(prop);\n  block.nodes = head.concat(tail);\n\n  return prop;\n}).raw = true;\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/adjust.js":"var utils = require('../utils');\n\n/**\n * Adjust HSL `color` `prop` by `amount`.\n *\n * @param {RGBA|HSLA} color\n * @param {String} prop\n * @param {Unit} amount\n * @return {RGBA}\n * @api private\n */\n\nmodule.exports = function adjust(color, prop, amount){\n  utils.assertColor(color, 'color');\n  utils.assertString(prop, 'prop');\n  utils.assertType(amount, 'unit', 'amount');\n  var hsl = color.hsla.clone();\n  prop = { hue: 'h', saturation: 's', lightness: 'l' }[prop.string];\n  if (!prop) throw new Error('invalid adjustment property');\n  var val = amount.val;\n  if ('%' == amount.type){\n    val = 'l' == prop && val > 0\n      ? (100 - hsl[prop]) * val / 100\n      : hsl[prop] * (val / 100);\n  }\n  hsl[prop] += val;\n  return hsl.rgba;\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/alpha.js":"var nodes = require('../nodes')\n  , rgba = require('./rgba');\n\n/**\n * Return the alpha component of the given `color`,\n * or set the alpha component to the optional second `value` argument.\n *\n * Examples:\n *\n *    alpha(#fff)\n *    // => 1\n *\n *    alpha(rgba(0,0,0,0.3))\n *    // => 0.3\n *\n *    alpha(#fff, 0.5)\n *    // => rgba(255,255,255,0.5)\n *\n * @param {RGBA|HSLA} color\n * @param {Unit} [value]\n * @return {Unit|RGBA}\n * @api public\n */\n\nmodule.exports = function alpha(color, value){\n  color = color.rgba;\n  if (value) {\n    return rgba(\n      new nodes.Unit(color.r),\n      new nodes.Unit(color.g),\n      new nodes.Unit(color.b),\n      value\n    );\n  }\n  return new nodes.Unit(color.a, '');\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/rgba.js":"var utils = require('../utils')\n  , nodes = require('../nodes');\n\n/**\n * Return a `RGBA` from the r,g,b,a channels.\n *\n * Examples:\n *\n *    rgba(255,0,0,0.5)\n *    // => rgba(255,0,0,0.5)\n *\n *    rgba(255,0,0,1)\n *    // => #ff0000\n *\n *    rgba(#ffcc00, 50%)\n *    // rgba(255,204,0,0.5)\n *\n * @param {Unit|RGBA|HSLA} red\n * @param {Unit} green\n * @param {Unit} blue\n * @param {Unit} alpha\n * @return {RGBA}\n * @api public\n */\n\nmodule.exports = function rgba(red, green, blue, alpha){\n  switch (arguments.length) {\n    case 1:\n      utils.assertColor(red);\n      return red.rgba;\n    case 2:\n      utils.assertColor(red);\n      var color = red.rgba;\n      utils.assertType(green, 'unit', 'alpha');\n      alpha = green.clone();\n      if ('%' == alpha.type) alpha.val /= 100;\n      return new nodes.RGBA(\n          color.r\n        , color.g\n        , color.b\n        , alpha.val);\n    default:\n      utils.assertType(red, 'unit', 'red');\n      utils.assertType(green, 'unit', 'green');\n      utils.assertType(blue, 'unit', 'blue');\n      utils.assertType(alpha, 'unit', 'alpha');\n      var r = '%' == red.type ? Math.round(red.val * 2.55) : red.val\n        , g = '%' == green.type ? Math.round(green.val * 2.55) : green.val\n        , b = '%' == blue.type ? Math.round(blue.val * 2.55) : blue.val;\n\n      alpha = alpha.clone();\n      if (alpha && '%' == alpha.type) alpha.val /= 100;\n      return new nodes.RGBA(\n          r\n        , g\n        , b\n        , alpha.val);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/base-convert.js":"var utils = require('../utils')\n  , nodes = require('../nodes');\n\n/**\n * Return a `Literal` `num` converted to the provided `base`, padded to `width`\n * with zeroes (default width is 2)\n *\n * @param {Number} num\n * @param {Number} base\n * @param {Number} width\n * @return {Literal}\n * @api public\n */\n\n(module.exports = function(num, base, width) {\n  utils.assertPresent(num, 'number');\n  utils.assertPresent(base, 'base');\n  num = utils.unwrap(num).nodes[0].val;\n  base = utils.unwrap(base).nodes[0].val;\n  width = (width && utils.unwrap(width).nodes[0].val) || 2;\n  var result = Number(num).toString(base);\n  while (result.length < width) {\n    result = '0' + result;\n  }\n  return new nodes.Literal(result);\n}).raw = true;\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/basename.js":"var utils = require('../utils')\n  , path = require('path');\n\n/**\n * Return the basename of `path`.\n *\n * @param {String} path\n * @return {String}\n * @api public\n */\n\nmodule.exports = function basename(p, ext){\n  utils.assertString(p, 'path');\n  return path.basename(p.val, ext && ext.val);\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/blend.js":"var utils = require('../utils')\n  , nodes = require('../nodes');\n\n/**\n * Blend the `top` color over the `bottom`\n *\n * Examples:\n *\n *     blend(rgba(#FFF, 0.5), #000)\n *     // => #808080\n * \n *     blend(rgba(#FFDE00,.42), #19C261)\n *     // => #7ace38\n * \n *     blend(rgba(lime, 0.5), rgba(red, 0.25))\n *     // => rgba(128,128,0,0.625)\n *\n * @param {RGBA|HSLA} top\n * @param {RGBA|HSLA} [bottom=#fff]\n * @return {RGBA}\n * @api public\n */\n\nmodule.exports = function blend(top, bottom){\n  // TODO: different blend modes like overlay etc.\n  utils.assertColor(top);\n  top = top.rgba;\n  bottom = bottom || new nodes.RGBA(255, 255, 255, 1);\n  utils.assertColor(bottom);\n  bottom = bottom.rgba;\n\n  return new nodes.RGBA(\n    top.r * top.a + bottom.r * (1 - top.a),\n    top.g * top.a + bottom.g * (1 - top.a),\n    top.b * top.a + bottom.b * (1 - top.a),\n    top.a + bottom.a - top.a * bottom.a);\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/blue.js":"var nodes = require('../nodes')\n  , rgba = require('./rgba');\n\n/**\n * Return the blue component of the given `color`,\n * or set the blue component to the optional second `value` argument.\n *\n * Examples:\n *\n *    blue(#00c)\n *    // => 204\n *\n *    blue(#000, 255)\n *    // => #00f\n *\n * @param {RGBA|HSLA} color\n * @param {Unit} [value]\n * @return {Unit|RGBA}\n * @api public\n */\n\nmodule.exports = function blue(color, value){\n  color = color.rgba;\n  if (value) {\n    return rgba(\n      new nodes.Unit(color.r),\n      new nodes.Unit(color.g),\n      value,\n      new nodes.Unit(color.a)\n    );\n  }\n  return new nodes.Unit(color.b, '');\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/clone.js":"var utils = require('../utils');\n\n/**\n * Return a clone of the given `expr`.\n *\n * @param {Expression} expr\n * @return {Node}\n * @api public\n */\n\n(module.exports = function clone(expr){\n  utils.assertPresent(expr, 'expr');\n  return expr.clone();\n}).raw = true;\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/component.js":"var utils = require('../utils')\n  , nodes = require('../nodes');\n\n/**\n * Color component name map.\n */\n\nvar componentMap = {\n    red: 'r'\n  , green: 'g'\n  , blue: 'b'\n  , alpha: 'a'\n  , hue: 'h'\n  , saturation: 's'\n  , lightness: 'l'\n};\n\n/**\n * Color component unit type map.\n */\n\nvar unitMap = {\n    hue: 'deg'\n  , saturation: '%'\n  , lightness: '%'\n};\n\n/**\n * Color type map.\n */\n\nvar typeMap = {\n    red: 'rgba'\n  , blue: 'rgba'\n  , green: 'rgba'\n  , alpha: 'rgba'\n  , hue: 'hsla'\n  , saturation: 'hsla'\n  , lightness: 'hsla'\n};\n\n/**\n * Return component `name` for the given `color`.\n *\n * @param {RGBA|HSLA} color\n * @param {String} name\n * @return {Unit}\n * @api public\n */\n\nmodule.exports = function component(color, name) {\n  utils.assertColor(color, 'color');\n  utils.assertString(name, 'name');\n  var name = name.string\n    , unit = unitMap[name]\n    , type = typeMap[name]\n    , name = componentMap[name];\n  if (!name) throw new Error('invalid color component \"' + name + '\"');\n  return new nodes.Unit(color[type][name], unit);\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/contrast.js":"var utils = require('../utils')\n  , nodes = require('../nodes')\n  , blend = require('./blend')\n  , luminosity = require('./luminosity');\n\n/**\n * Returns the contrast ratio object between `top` and `bottom` colors,\n * based on http://leaverou.github.io/contrast-ratio/\n * and https://github.com/LeaVerou/contrast-ratio/blob/gh-pages/color.js#L108\n *\n * Examples:\n *\n *     contrast(#000, #fff).ratio\n *     => 21\n *\n *     contrast(#000, rgba(#FFF, 0.5))\n *     => { \"ratio\": \"13.15;\", \"error\": \"7.85\", \"min\": \"5.3\", \"max\": \"21\" }\n *\n * @param {RGBA|HSLA} top\n * @param {RGBA|HSLA} [bottom=#fff]\n * @return {Object}\n * @api public\n */\n\nmodule.exports = function contrast(top, bottom){\n  if ('rgba' != top.nodeName && 'hsla' != top.nodeName) {\n    return new nodes.Literal('contrast(' + (top.isNull ? '' : top.toString()) + ')');\n  }\n  var result = new nodes.Object();\n  top = top.rgba;\n  bottom = bottom || new nodes.RGBA(255, 255, 255, 1);\n  utils.assertColor(bottom);\n  bottom = bottom.rgba;\n  function contrast(top, bottom) {\n    if (1 > top.a) {\n      top = blend(top, bottom);\n    }\n    var l1 = luminosity(bottom).val + 0.05\n      , l2 = luminosity(top).val + 0.05\n      , ratio = l1 / l2;\n\n    if (l2 > l1) {\n      ratio = 1 / ratio;\n    }\n    return Math.round(ratio * 10) / 10;\n  }\n\n  if (1 <= bottom.a) {\n    var resultRatio = new nodes.Unit(contrast(top, bottom));\n    result.set('ratio', resultRatio);\n    result.set('error', new nodes.Unit(0));\n    result.set('min', resultRatio);\n    result.set('max', resultRatio);\n  } else {\n    var onBlack = contrast(top, blend(bottom, new nodes.RGBA(0, 0, 0, 1)))\n      , onWhite = contrast(top, blend(bottom, new nodes.RGBA(255, 255, 255, 1)))\n      , max = Math.max(onBlack, onWhite);\n    function processChannel(topChannel, bottomChannel) {\n      return Math.min(Math.max(0, (topChannel - bottomChannel * bottom.a) / (1 - bottom.a)), 255);\n    }\n    var closest = new nodes.RGBA(\n      processChannel(top.r, bottom.r),\n      processChannel(top.g, bottom.g),\n      processChannel(top.b, bottom.b),\n      1\n    );\n    var min = contrast(top, blend(bottom, closest));\n\n    result.set('ratio', new nodes.Unit(Math.round((min + max) * 50) / 100));\n    result.set('error', new nodes.Unit(Math.round((max - min) * 50) / 100));\n    result.set('min', new nodes.Unit(min));\n    result.set('max', new nodes.Unit(max));\n  }\n  return result;\n}\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/luminosity.js":"var utils = require('../utils')\n  , nodes = require('../nodes');\n\n/**\n * Returns the relative luminance of the given `color`,\n * see http://www.w3.org/TR/WCAG20/#relativeluminancedef\n *\n * Examples:\n *\n *     luminosity(white)\n *     // => 1\n * \n *     luminosity(#000)\n *     // => 0\n * \n *     luminosity(red)\n *     // => 0.2126\n *\n * @param {RGBA|HSLA} color\n * @return {Unit}\n * @api public\n */\n\nmodule.exports = function luminosity(color){\n  utils.assertColor(color);\n  color = color.rgba;\n  function processChannel(channel) {\n    channel = channel / 255;\n    return (0.03928 > channel)\n      ? channel / 12.92\n      : Math.pow(((channel + 0.055) / 1.055), 2.4);\n  }\n  return new nodes.Unit(\n    0.2126 * processChannel(color.r)\n    + 0.7152 * processChannel(color.g)\n    + 0.0722 * processChannel(color.b)\n  );\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/convert.js":"var utils = require('../utils');\n\n/**\n * Like `unquote` but tries to convert\n * the given `str` to a Stylus node.\n *\n * @param {String} str\n * @return {Node}\n * @api public\n */\n\nmodule.exports = function convert(str){\n  utils.assertString(str, 'str');\n  return utils.parseString(str.string);\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/current-media.js":"var nodes = require('../nodes');\n\n/**\n * Returns the @media string for the current block\n *\n * @return {String}\n * @api public\n */\n\nmodule.exports = function currentMedia(){\n  var self = this;\n  return new nodes.String(lookForMedia(this.closestBlock.node) || '');\n\n  function lookForMedia(node){\n    if ('media' == node.nodeName) {\n      node.val = self.visit(node.val);\n      return node.toString();\n    } else if (node.block.parent.node) {\n      return lookForMedia(node.block.parent.node);\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/define.js":"var utils = require('../utils')\n  , nodes = require('../nodes');\n\n/**\n * Set a variable `name` on current scope.\n *\n * @param {String} name\n * @param {Expression} expr\n * @param {Boolean} [global]\n * @api public\n */\n\nmodule.exports = function define(name, expr, global){\n  utils.assertType(name, 'string', 'name');\n  expr = utils.unwrap(expr);\n  var scope = this.currentScope;\n  if (global && global.toBoolean().isTrue) {\n    scope = this.global.scope;\n  }\n  var node = new nodes.Ident(name.val, expr);\n  scope.add(node);\n  return nodes.null;\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/dirname.js":"var utils = require('../utils')\n  , path = require('path');\n\n/**\n * Return the dirname of `path`.\n *\n * @param {String} path\n * @return {String}\n * @api public\n */\n\nmodule.exports = function dirname(p){\n  utils.assertString(p, 'path');\n  return path.dirname(p.val).replace(/\\\\/g, '/');\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/error.js":"var utils = require('../utils');\n\n/**\n * Throw an error with the given `msg`.\n *\n * @param {String} msg\n * @api public\n */\n\nmodule.exports = function error(msg){\n  utils.assertType(msg, 'string', 'msg');\n  var err = new Error(msg.val);\n  err.fromStylus = true;\n  throw err;\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/extname.js":"var utils = require('../utils')\n  , path = require('path');\n\n/**\n * Return the extname of `path`.\n *\n * @param {String} path\n * @return {String}\n * @api public\n */\n\nmodule.exports = function extname(p){\n  utils.assertString(p, 'path');\n  return path.extname(p.val);\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/green.js":"var nodes = require('../nodes')\n  , rgba = require('./rgba');\n\n/**\n * Return the green component of the given `color`,\n * or set the green component to the optional second `value` argument.\n *\n * Examples:\n *\n *    green(#0c0)\n *    // => 204\n *\n *    green(#000, 255)\n *    // => #0f0\n *\n * @param {RGBA|HSLA} color\n * @param {Unit} [value]\n * @return {Unit|RGBA}\n * @api public\n */\n\nmodule.exports = function green(color, value){\n  color = color.rgba;\n  if (value) {\n    return rgba(\n      new nodes.Unit(color.r),\n      value,\n      new nodes.Unit(color.b),\n      new nodes.Unit(color.a)\n    );\n  }\n  return new nodes.Unit(color.g, '');\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/hsl.js":"var utils = require('../utils')\n  , nodes = require('../nodes')\n  , hsla = require('./hsla');\n\n/**\n * Convert the given `color` to an `HSLA` node,\n * or h,s,l component values.\n *\n * Examples:\n *\n *    hsl(10, 50, 30)\n *    // => HSLA\n *\n *    hsl(#ffcc00)\n *    // => HSLA\n *\n * @param {Unit|HSLA|RGBA} hue\n * @param {Unit} saturation\n * @param {Unit} lightness\n * @return {HSLA}\n * @api public\n */\n\nmodule.exports = function hsl(hue, saturation, lightness){\n  if (1 == arguments.length) {\n    utils.assertColor(hue, 'color');\n    return hue.hsla;\n  } else {\n    return hsla(\n        hue\n      , saturation\n      , lightness\n      , new nodes.Unit(1));\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/hsla.js":"var utils = require('../utils')\n  , nodes = require('../nodes');\n\n/**\n * Convert the given `color` to an `HSLA` node,\n * or h,s,l,a component values.\n *\n * Examples:\n *\n *    hsla(10deg, 50%, 30%, 0.5)\n *    // => HSLA\n *\n *    hsla(#ffcc00)\n *    // => HSLA\n *\n * @param {RGBA|HSLA|Unit} hue\n * @param {Unit} saturation\n * @param {Unit} lightness\n * @param {Unit} alpha\n * @return {HSLA}\n * @api public\n */\n\nmodule.exports = function hsla(hue, saturation, lightness, alpha){\n  switch (arguments.length) {\n    case 1:\n      utils.assertColor(hue);\n      return hue.hsla;\n    case 2:\n      utils.assertColor(hue);\n      var color = hue.hsla;\n      utils.assertType(saturation, 'unit', 'alpha');\n      var alpha = saturation.clone();\n      if ('%' == alpha.type) alpha.val /= 100;\n      return new nodes.HSLA(\n          color.h\n        , color.s\n        , color.l\n        , alpha.val);\n    default:\n      utils.assertType(hue, 'unit', 'hue');\n      utils.assertType(saturation, 'unit', 'saturation');\n      utils.assertType(lightness, 'unit', 'lightness');\n      utils.assertType(alpha, 'unit', 'alpha');\n      var alpha = alpha.clone();\n      if (alpha && '%' == alpha.type) alpha.val /= 100;\n      return new nodes.HSLA(\n          hue.val\n        , saturation.val\n        , lightness.val\n        , alpha.val);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/hue.js":"var nodes = require('../nodes')\n  , hsla = require('./hsla')\n  , component = require('./component');\n\n/**\n * Return the hue component of the given `color`,\n * or set the hue component to the optional second `value` argument.\n *\n * Examples:\n *\n *    hue(#00c)\n *    // => 240deg\n *\n *    hue(#00c, 90deg)\n *    // => #6c0\n *\n * @param {RGBA|HSLA} color\n * @param {Unit} [value]\n * @return {Unit|RGBA}\n * @api public\n */\n\nmodule.exports = function hue(color, value){\n  if (value) {\n    var hslaColor = color.hsla;\n    return hsla(\n      value,\n      new nodes.Unit(hslaColor.s),\n      new nodes.Unit(hslaColor.l),\n      new nodes.Unit(hslaColor.a)\n    )\n  }\n  return component(color, new nodes.String('hue'));\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/image-size.js":"var utils = require('../utils')\n  , nodes = require('../nodes')\n  , Image = require('./image');\n\n/**\n * Return the width and height of the given `img` path.\n *\n * Examples:\n *\n *    image-size('foo.png')\n *    // => 200px 100px\n *\n *    image-size('foo.png')[0]\n *    // => 200px\n *\n *    image-size('foo.png')[1]\n *    // => 100px\n *\n * Can be used to test if the image exists,\n * using an optional argument set to `true`\n * (without this argument this function throws error\n * if there is no such image).\n *\n * Example:\n *\n *    image-size('nosuchimage.png', true)[0]\n *    // => 0\n *\n * @param {String} img\n * @param {Boolean} ignoreErr\n * @return {Expression}\n * @api public\n */\n\nmodule.exports = function imageSize(img, ignoreErr) {\n  utils.assertType(img, 'string', 'img');\n  try {\n    var img = new Image(this, img.string);\n  } catch (err) {\n    if (ignoreErr) {\n      return [new nodes.Unit(0), new nodes.Unit(0)];\n    } else {\n      throw err;\n    }\n  }\n\n  // Read size\n  img.open();\n  var size = img.size();\n  img.close();\n\n  // Return (w h)\n  var expr = [];\n  expr.push(new nodes.Unit(size[0], 'px'));\n  expr.push(new nodes.Unit(size[1], 'px'));\n\n  return expr;\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/image.js":"\n\n/*!\n * Stylus - plugin - url\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar utils = require('../utils')\n  , nodes = require('../nodes')\n  , fs = require('fs')\n  , path = require('path')\n  , sax = require('sax');\n\n/**\n * Initialize a new `Image` with the given `ctx` and `path.\n *\n * @param {Evaluator} ctx\n * @param {String} path\n * @api private\n */\n\nvar Image = module.exports = function Image(ctx, path) {\n  this.ctx = ctx;\n  this.path = utils.lookup(path, ctx.paths);\n  if (!this.path) throw new Error('failed to locate file ' + path);\n};\n\n/**\n * Open the image for reading.\n *\n * @api private\n */\n\nImage.prototype.open = function(){\n  this.fd = fs.openSync(this.path, 'r');\n  this.length = fs.fstatSync(this.fd).size;\n  this.extname = path.extname(this.path).slice(1);\n};\n\n/**\n * Close the file.\n *\n * @api private\n */\n\nImage.prototype.close = function(){\n  if (this.fd) fs.closeSync(this.fd);\n};\n\n/**\n * Return the type of image, supports:\n *\n *  - gif\n *  - png\n *  - jpeg\n *  - svg\n *\n * @return {String}\n * @api private\n */\n\nImage.prototype.type = function(){\n  var type\n    , buf = new Buffer(4);\n  \n  fs.readSync(this.fd, buf, 0, 4, 0);\n\n  // GIF\n  if (0x47 == buf[0] && 0x49 == buf[1] && 0x46 == buf[2]) type = 'gif';\n\n  // PNG\n  else if (0x50 == buf[1] && 0x4E == buf[2] && 0x47 == buf[3]) type = 'png';\n\n  // JPEG\n  else if (0xff == buf[0] && 0xd8 == buf[1]) type = 'jpeg';\n\n  // SVG\n  else if ('svg' == this.extname) type = this.extname;\n\n  return type;\n};\n\n/**\n * Return image dimensions `[width, height]`.\n *\n * @return {Array}\n * @api private\n */\n\nImage.prototype.size = function(){\n  var type = this.type()\n    , width\n    , height\n    , buf\n    , offset\n    , blockSize\n    , parser;\n\n  function uint16(b) { return b[1] << 8 | b[0]; }\n  function uint32(b) { return b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]; } \n\n  // Determine dimensions\n  switch (type) {\n    case 'jpeg':\n      buf = new Buffer(this.length);\n      fs.readSync(this.fd, buf, 0, this.length, 0);\n      offset = 4;\n      blockSize = buf[offset] << 8 | buf[offset + 1];\n\n      while (offset < this.length) {\n        offset += blockSize;\n        if (offset >= this.length || 0xff != buf[offset]) break;\n        // SOF0 or SOF2 (progressive)\n        if (0xc0 == buf[offset + 1] || 0xc2 == buf[offset + 1]) {\n          height = buf[offset + 5] << 8 | buf[offset + 6];\n          width = buf[offset + 7] << 8 | buf[offset + 8];\n        } else {\n          offset += 2;\n          blockSize = buf[offset] << 8 | buf[offset + 1];\n        }\n      }\n      break;\n    case 'png':\n      buf = new Buffer(8);\n      // IHDR chunk width / height uint32_t big-endian\n      fs.readSync(this.fd, buf, 0, 8, 16);\n      width = uint32(buf);\n      height = uint32(buf.slice(4, 8));\n      break;\n    case 'gif':\n      buf = new Buffer(4);\n      // width / height uint16_t little-endian\n      fs.readSync(this.fd, buf, 0, 4, 6);\n      width = uint16(buf);\n      height = uint16(buf.slice(2, 4));\n      break;\n    case 'svg':\n      offset = Math.min(this.length, 1024);\n      buf = new Buffer(offset);\n      fs.readSync(this.fd, buf, 0, offset, 0);\n      buf = buf.toString('utf8');\n      parser = sax.parser(true);\n      parser.onopentag = function(node) {\n        if ('svg' == node.name && node.attributes.width && node.attributes.height) {\n          width = parseInt(node.attributes.width, 10);\n          height = parseInt(node.attributes.height, 10);\n        }\n      };\n      parser.write(buf).close();\n      break;\n  }\n\n  if ('number' != typeof width) throw new Error('failed to find width of \"' + this.path + '\"');\n  if ('number' != typeof height) throw new Error('failed to find height of \"' + this.path + '\"');\n\n  return [width, height];\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/json.js":"var utils = require('../utils')\n  , nodes = require('../nodes')\n  , readFile = require('fs').readFileSync;\n\n/**\n * Convert a .json file into stylus variables or object.\n * Nested variable object keys are joined with a dash (-)\n *\n * Given this sample media-queries.json file:\n * {\n *   \"small\": \"screen and (max-width:400px)\",\n *   \"tablet\": {\n *     \"landscape\": \"screen and (min-width:600px) and (orientation:landscape)\",\n *     \"portrait\": \"screen and (min-width:600px) and (orientation:portrait)\"\n *   }\n * }\n *\n * Examples:\n *\n *    json('media-queries.json')\n *\n *    @media small\n *    // => @media screen and (max-width:400px)\n *\n *    @media tablet-landscape\n *    // => @media screen and (min-width:600px) and (orientation:landscape)\n *\n *    vars = json('vars.json', { hash: true })\n *    body\n *      width: vars.width\n *\n * @param {String} path\n * @param {Boolean} [local]\n * @param {String} [namePrefix]\n * @api public\n*/\n\nmodule.exports = function(path, local, namePrefix){\n  utils.assertString(path, 'path');\n\n  // lookup\n  path = path.string;\n  var found = utils.lookup(path, this.options.paths, this.options.filename)\n    , options = (local && 'object' == local.nodeName) && local;\n\n  if (!found) {\n    // optional JSON file\n    if (options && options.get('optional').toBoolean().isTrue) {\n      return nodes.null;\n    }\n    throw new Error('failed to locate .json file ' + path);\n  }\n\n  // read\n  var json = JSON.parse(readFile(found, 'utf8'));\n\n  if (options) {\n    return convert(json, options);\n  } else {\n    oldJson.call(this, json, local, namePrefix);\n  }\n\n  function convert(obj, options){\n    var ret = new nodes.Object()\n      , leaveStrings = options.get('leave-strings').toBoolean();\n\n    for (var key in obj) {\n      var val = obj[key];\n      if ('object' == typeof val) {\n        ret.set(key, convert(val, options));\n      } else {\n        val = utils.coerce(val);\n        if ('string' == val.nodeName && leaveStrings.isFalse) {\n          val = utils.parseString(val.string);\n        }\n        ret.set(key, val);\n      }\n    }\n    return ret;\n  }\n};\n\n/**\n * Old `json` BIF.\n *\n * @api private\n */\n\nfunction oldJson(json, local, namePrefix){\n  if (namePrefix) {\n    utils.assertString(namePrefix, 'namePrefix');\n    namePrefix = namePrefix.val;\n  } else {\n    namePrefix = '';\n  }\n  local = local ? local.toBoolean() : new nodes.Boolean(local);\n  var scope = local.isTrue ? this.currentScope : this.global.scope;\n\n  convert(json);\n  return;\n\n  function convert(obj, prefix){\n    prefix = prefix ? prefix + '-' : '';\n    for (var key in obj){\n      var val = obj[key];\n      var name = prefix + key;\n      if ('object' == typeof val) {\n        convert(val, name);\n      } else {\n        val = utils.coerce(val);\n        if ('string' == val.nodeName) val = utils.parseString(val.string);\n        scope.add({ name: namePrefix + name, val: val });\n      }\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/length.js":"var utils = require('../utils');\n\n/**\n * Return length of the given `expr`.\n *\n * @param {Expression} expr\n * @return {Unit}\n * @api public\n */\n\n(module.exports = function length(expr){\n  if (expr) {\n    if (expr.nodes) {\n      var nodes = utils.unwrap(expr).nodes;\n      if (1 == nodes.length && 'object' == nodes[0].nodeName) {\n        return nodes[0].length;\n      } else {\n        return nodes.length;\n      }\n    } else {\n      return 1;\n    }\n  }\n  return 0;\n}).raw = true;\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/lightness.js":"var nodes = require('../nodes')\n  , hsla = require('./hsla')\n  , component = require('./component');\n\n/**\n * Return the lightness component of the given `color`,\n * or set the lightness component to the optional second `value` argument.\n *\n * Examples:\n *\n *    lightness(#00c)\n *    // => 100%\n *\n *    lightness(#00c, 80%)\n *    // => #99f\n *\n * @param {RGBA|HSLA} color\n * @param {Unit} [value]\n * @return {Unit|RGBA}\n * @api public\n */\n\nmodule.exports = function lightness(color, value){\n  if (value) {\n    var hslaColor = color.hsla;\n    return hsla(\n      new nodes.Unit(hslaColor.h),\n      new nodes.Unit(hslaColor.s),\n      value,\n      new nodes.Unit(hslaColor.a)\n    )\n  }\n  return component(color, new nodes.String('lightness'));\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/list-separator.js":"var utils = require('../utils')\n  , nodes = require('../nodes');\n\n/**\n * Return the separator of the given `list`.\n *\n * Examples:\n *\n *    list1 = a b c\n *    list-separator(list1)\n *    // => ' '\n *\n *    list2 = a, b, c\n *    list-separator(list2)\n *    // => ','\n *\n * @param {Experssion} list\n * @return {String}\n * @api public\n */\n\n(module.exports = function listSeparator(list){\n  list = utils.unwrap(list);\n  return new nodes.String(list.isList ? ',' : ' ');\n}).raw = true;\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/lookup.js":"var utils = require('../utils')\n  , nodes = require('../nodes');\n\n/**\n * Lookup variable `name` or return Null.\n *\n * @param {String} name\n * @return {Mixed}\n * @api public\n */\n\nmodule.exports = function lookup(name){\n  utils.assertType(name, 'string', 'name');\n  var node = this.lookup(name.val);\n  if (!node) return nodes.null;\n  return this.visit(node);\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/match.js":"var utils = require('../utils')\n  , nodes = require('../nodes');\n\nvar VALID_FLAGS = 'igm';\n\n/**\n * retrieves the matches when matching a `val`(string)\n * against a `pattern`(regular expression).\n *\n * Examples:\n *   $regex = '^(height|width)?([<>=]{1,})(.*)'\n *\n *   match($regex,'height>=sm')\n * \t // => ('height>=sm' 'height' '>=' 'sm')\n * \t // => also truthy\n *\n *   match($regex, 'lorem ipsum')\n *   // => null\n *\n * @param {String} pattern\n * @param {String|Ident} val\n * @param {String|Ident} [flags='']\n * @return {String|Null}\n * @api public\n */\n\nmodule.exports = function match(pattern, val, flags){\n  utils.assertType(pattern, 'string', 'pattern');\n  utils.assertString(val, 'val');\n  var re = new RegExp(pattern.val, validateFlags(flags) ? flags.string : '');\n  return val.string.match(re);\n};\n\nfunction validateFlags(flags) {\n  flags = flags && flags.string;\n\n  if (flags) {\n    return flags.split('').every(function(flag) {\n      return ~VALID_FLAGS.indexOf(flag);\n    });\n  }\n  return false;\n}\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/math.js":"var utils = require('../utils')\n  , nodes = require('../nodes');\n\n/**\n * Apply Math `fn` to `n`.\n *\n * @param {Unit} n\n * @param {String} fn\n * @return {Unit}\n * @api private\n */\n\nmodule.exports = function math(n, fn){\n  utils.assertType(n, 'unit', 'n');\n  utils.assertString(fn, 'fn');\n  return new nodes.Unit(Math[fn.string](n.val), n.type);\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/merge.js":"var utils = require('../utils');\n\n/**\n * Merge the object `dest` with the given args.\n *\n * @param {Object} dest\n * @param {Object} ...\n * @return {Object} dest\n * @api public\n */\n\n(module.exports = function merge(dest){\n  utils.assertPresent(dest, 'dest');\n  dest = utils.unwrap(dest).first;\n  utils.assertType(dest, 'object', 'dest');\n\n  var last = utils.unwrap(arguments[arguments.length - 1]).first\n    , deep = (true === last.val);\n\n  for (var i = 1, len = arguments.length - deep; i < len; ++i) {\n    utils.merge(dest.vals, utils.unwrap(arguments[i]).first.vals, deep);\n  }\n  return dest;\n}).raw = true;\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/operate.js":"var utils = require('../utils');\n\n/**\n * Perform `op` on the `left` and `right` operands.\n *\n * @param {String} op\n * @param {Node} left\n * @param {Node} right\n * @return {Node}\n * @api public\n */\n\nmodule.exports = function operate(op, left, right){\n  utils.assertType(op, 'string', 'op');\n  utils.assertPresent(left, 'left');\n  utils.assertPresent(right, 'right');\n  return left.operate(op.val, right);\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/opposite-position.js":"var utils = require('../utils')\n  , nodes = require('../nodes');\n\n/**\n * Return the opposites of the given `positions`.\n *\n * Examples:\n *\n *    opposite-position(top left)\n *    // => bottom right\n *\n * @param {Expression} positions\n * @return {Expression}\n * @api public\n */\n\n(module.exports = function oppositePosition(positions){\n  var expr = [];\n  utils.unwrap(positions).nodes.forEach(function(pos, i){\n    utils.assertString(pos, 'position ' + i);\n    pos = (function(){ switch (pos.string) {\n      case 'top': return 'bottom';\n      case 'bottom': return 'top';\n      case 'left': return 'right';\n      case 'right': return 'left';\n      case 'center': return 'center';\n      default: throw new Error('invalid position ' + pos);\n    }})();\n    expr.push(new nodes.Literal(pos));\n  });\n  return expr;\n}).raw = true;\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/p.js":"var utils = require('../utils')\n  , nodes = require('../nodes');\n\n/**\n * Inspect the given `expr`.\n *\n * @param {Expression} expr\n * @api public\n */\n\n(module.exports = function p(){\n  [].slice.call(arguments).forEach(function(expr){\n    expr = utils.unwrap(expr);\n    if (!expr.nodes.length) return;\n    console.log('\\u001b[90minspect:\\u001b[0m %s', expr.toString().replace(/^\\(|\\)$/g, ''));\n  })\n  return nodes.null;\n}).raw = true;\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/pathjoin.js":"var path = require('path');\n\n/**\n * Peform a path join.\n *\n * @param {String} path\n * @return {String}\n * @api public\n */\n\n(module.exports = function pathjoin(){\n  var paths = [].slice.call(arguments).map(function(path){\n    return path.first.string;\n  });\n  return path.join.apply(null, paths).replace(/\\\\/g, '/');\n}).raw = true;\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/pop.js":"var utils = require('../utils');\n\n/**\n * Pop a value from `expr`.\n *\n * @param {Expression} expr\n * @return {Node}\n * @api public\n */\n\n(module.exports = function pop(expr) {\n  expr = utils.unwrap(expr);\n  return expr.nodes.pop();\n}).raw = true;\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/push.js":"var utils = require('../utils');\n\n/**\n * Push the given args to `expr`.\n *\n * @param {Expression} expr\n * @param {Node} ...\n * @return {Unit}\n * @api public\n */\n\n(module.exports = function(expr){\n  expr = utils.unwrap(expr);\n  for (var i = 1, len = arguments.length; i < len; ++i) {\n    expr.nodes.push(utils.unwrap(arguments[i]).clone());\n  }\n  return expr.nodes.length;\n}).raw = true;\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/range.js":"var utils = require('../utils')\n  , nodes = require('../nodes');\n\n/**\n * Returns a list of units from `start` to `stop`\n * by `step`. If `step` argument is omitted,\n * it defaults to 1.\n *\n * @param {Unit} start\n * @param {Unit} stop\n * @param {Unit} [step]\n * @return {Expression}\n * @api public\n */\n\nmodule.exports = function range(start, stop, step){\n  utils.assertType(start, 'unit', 'start');\n  utils.assertType(stop, 'unit', 'stop');\n  if (step) {\n    utils.assertType(step, 'unit', 'step');\n    if (0 == step.val) {\n      throw new Error('ArgumentError: \"step\" argument must not be zero');\n    }\n  } else {\n    step = new nodes.Unit(1);\n  }\n  var list = new nodes.Expression;\n  for (var i = start.val; i <= stop.val; i += step.val) {\n    list.push(new nodes.Unit(i, start.type));\n  }\n  return list;\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/red.js":"var nodes = require('../nodes')\n  , rgba = require('./rgba');\n\n/**\n * Return the red component of the given `color`,\n * or set the red component to the optional second `value` argument.\n *\n * Examples:\n *\n *    red(#c00)\n *    // => 204\n *\n *    red(#000, 255)\n *    // => #f00\n *\n * @param {RGBA|HSLA} color\n * @param {Unit} [value]\n * @return {Unit|RGBA}\n * @api public\n */\n\nmodule.exports = function red(color, value){\n  color = color.rgba;\n  if (value) {\n    return rgba(\n      value,\n      new nodes.Unit(color.g),\n      new nodes.Unit(color.b),\n      new nodes.Unit(color.a)\n    );\n  }\n  return new nodes.Unit(color.r, '');\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/remove.js":"var utils = require('../utils');\n\n/**\n * Remove the given `key` from the `object`.\n *\n * @param {Object} object\n * @param {String} key\n * @return {Object}\n * @api public\n */\n\nmodule.exports = function remove(object, key){\n  utils.assertType(object, 'object', 'object');\n  utils.assertString(key, 'key');\n  delete object.vals[key.string];\n  return object;\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/replace.js":"var utils = require('../utils')\n  , nodes = require('../nodes');\n\n/**\n * Returns string with all matches of `pattern` replaced by `replacement` in given `val`\n *\n * @param {String} pattern\n * @param {String} replacement\n * @param {String|Ident} val\n * @return {String|Ident}\n * @api public\n */\n\nmodule.exports = function replace(pattern, replacement, val){\n  utils.assertString(pattern, 'pattern');\n  utils.assertString(replacement, 'replacement');\n  utils.assertString(val, 'val');\n  pattern = new RegExp(pattern.string, 'g');\n  var res = val.string.replace(pattern, replacement.string);\n  return val instanceof nodes.Ident\n    ? new nodes.Ident(res)\n    : new nodes.String(res);\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/rgb.js":"var utils = require('../utils')\n  , nodes = require('../nodes')\n  , rgba = require('./rgba');\n\n/**\n * Return a `RGBA` from the r,g,b channels.\n *\n * Examples:\n *\n *    rgb(255,204,0)\n *    // => #ffcc00\n *\n *    rgb(#fff)\n *    // => #fff\n *\n * @param {Unit|RGBA|HSLA} red\n * @param {Unit} green\n * @param {Unit} blue\n * @return {RGBA}\n * @api public\n */\n\nmodule.exports = function rgb(red, green, blue){\n  switch (arguments.length) {\n    case 1:\n      utils.assertColor(red);\n      var color = red.rgba;\n      return new nodes.RGBA(\n          color.r\n        , color.g\n        , color.b\n        , 1);\n    default:\n      return rgba(\n          red\n        , green\n        , blue\n        , new nodes.Unit(1));\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/s.js":"var utils = require('../utils')\n  , nodes = require('../nodes')\n  , Compiler = require('../visitor/compiler');\n\n/**\n * Return a `Literal` with the given `fmt`, and\n * variable number of arguments.\n *\n * @param {String} fmt\n * @param {Node} ...\n * @return {Literal}\n * @api public\n */\n\n(module.exports = function s(fmt){\n  fmt = utils.unwrap(fmt).nodes[0];\n  utils.assertString(fmt);\n  var self = this\n    , str = fmt.string\n    , args = arguments\n    , i = 1;\n\n  // format\n  str = str.replace(/%(s|d)/g, function(_, specifier){\n    var arg = args[i++] || nodes.null;\n    switch (specifier) {\n      case 's':\n        return new Compiler(arg, self.options).compile();\n      case 'd':\n        arg = utils.unwrap(arg).first;\n        if ('unit' != arg.nodeName) throw new Error('%d requires a unit');\n        return arg.val;\n    }\n  });\n\n  return new nodes.Literal(str);\n}).raw = true;\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/visitor/compiler.js":"/*!\n * Stylus - Compiler\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Visitor = require('./')\n  , utils = require('../utils')\n  , fs = require('fs');\n\n/**\n * Initialize a new `Compiler` with the given `root` Node\n * and the following `options`.\n *\n * Options:\n *\n *   - `compress`  Compress the CSS output (default: false)\n *\n * @param {Node} root\n * @api public\n */\n\nvar Compiler = module.exports = function Compiler(root, options) {\n  options = options || {};\n  this.compress = options.compress;\n  this.firebug = options.firebug;\n  this.linenos = options.linenos;\n  this.spaces = options['indent spaces'] || 2;\n  this.indents = 1;\n  Visitor.call(this, root);\n  this.stack = [];\n};\n\n/**\n * Inherit from `Visitor.prototype`.\n */\n\nCompiler.prototype.__proto__ = Visitor.prototype;\n\n/**\n * Compile to css, and return a string of CSS.\n *\n * @return {String}\n * @api private\n */\n\nCompiler.prototype.compile = function(){\n  return this.visit(this.root);\n};\n\n/**\n * Output `str`\n *\n * @param {String} str\n * @param {Node} node\n * @return {String}\n * @api private\n */\n\nCompiler.prototype.out = function(str, node){\n  return str;\n};\n\n/**\n * Return indentation string.\n *\n * @return {String}\n * @api private\n */\n\nCompiler.prototype.__defineGetter__('indent', function(){\n  if (this.compress) return '';\n  return new Array(this.indents).join(Array(this.spaces + 1).join(' '));\n});\n\n/**\n * Check if given `node` needs brackets.\n *\n * @param {Node} node\n * @return {Boolean}\n * @api private\n */\n\nCompiler.prototype.needBrackets = function(node){\n  return 1 == this.indents\n    || 'atrule' != node.nodeName\n    || node.hasOnlyProperties;\n};\n\n/**\n * Visit Root.\n */\n\nCompiler.prototype.visitRoot = function(block){\n  this.buf = '';\n  for (var i = 0, len = block.nodes.length; i < len; ++i) {\n    var node = block.nodes[i];\n    if (this.linenos || this.firebug) this.debugInfo(node);\n    var ret = this.visit(node);\n    if (ret) this.buf += this.out(ret + '\\n', node);\n  }\n  return this.buf;\n};\n\n/**\n * Visit Block.\n */\n\nCompiler.prototype.visitBlock = function(block){\n  var node\n    , separator = this.compress ? '' : '\\n'\n    , needBrackets;\n\n  if (block.hasProperties && !block.lacksRenderedSelectors) {\n    needBrackets = this.needBrackets(block.node);\n\n    if (needBrackets) {\n      this.buf += this.out(this.compress ? '{' : ' {\\n');\n      ++this.indents;\n    }\n    for (var i = 0, len = block.nodes.length; i < len; ++i) {\n      this.last = len - 1 == i;\n      node = block.nodes[i];\n      switch (node.nodeName) {\n        case 'null':\n        case 'expression':\n        case 'function':\n        case 'group':\n        case 'block':\n        case 'unit':\n        case 'media':\n        case 'keyframes':\n        case 'atrule':\n        case 'supports':\n          continue;\n        // inline comments\n        case !this.compress && node.inline && 'comment':\n          this.buf = this.buf.slice(0, -1);\n          this.buf += this.out(' ' + this.visit(node) + '\\n', node);\n          break;\n        case 'property':\n          var ret = this.visit(node) + separator;\n          this.buf += this.compress ? ret : this.out(ret, node);\n          break;\n        default:\n          this.buf += this.out(this.visit(node) + separator, node);\n      }\n    }\n    if (needBrackets) {\n      --this.indents;\n      this.buf += this.out(this.indent + '}' + separator);\n    }\n  }\n\n  // Nesting\n  for (var i = 0, len = block.nodes.length; i < len; ++i) {\n    node = block.nodes[i];\n    switch (node.nodeName) {\n      case 'group':\n      case 'block':\n      case 'keyframes':\n        if (this.linenos || this.firebug) this.debugInfo(node);\n        this.visit(node);\n        break;\n      case 'media':\n      case 'import':\n      case 'atrule':\n      case 'supports':\n        this.visit(node);\n        break;\n      case 'comment':\n        // only show unsuppressed comments\n        if (!node.suppress) {\n          this.buf += this.out(this.indent + this.visit(node) + '\\n', node);\n        }\n        break;\n      case 'charset':\n      case 'literal':\n      case 'namespace':\n        this.buf += this.out(this.visit(node) + '\\n', node);\n        break;\n    }\n  }\n};\n\n/**\n * Visit Keyframes.\n */\n\nCompiler.prototype.visitKeyframes = function(node){\n  if (!node.frames) return;\n\n  var prefix = 'official' == node.prefix\n    ? ''\n    : '-' + node.prefix + '-';\n\n  this.buf += this.out('@' + prefix + 'keyframes '\n    + this.visit(node.val)\n    + (this.compress ? '{' : ' {\\n'), node);\n\n  this.keyframe = true;\n  ++this.indents;\n  this.visit(node.block);\n  --this.indents;\n  this.keyframe = false;\n\n  this.buf += this.out('}' + (this.compress ? '' : '\\n'));\n};\n\n/**\n * Visit Media.\n */\n\nCompiler.prototype.visitMedia = function(media){\n  var val = media.val;\n  if (!media.hasOutput || !val.nodes.length) return;\n\n  this.buf += this.out('@media ', media);\n  this.visit(val);\n  this.buf += this.out(this.compress ? '{' : ' {\\n');\n  ++this.indents;\n  this.visit(media.block);\n  --this.indents;\n  this.buf += this.out('}' + (this.compress ? '' : '\\n'));\n};\n\n/**\n * Visit QueryList.\n */\n\nCompiler.prototype.visitQueryList = function(queries){\n  for (var i = 0, len = queries.nodes.length; i < len; ++i) {\n    this.visit(queries.nodes[i]);\n    if (len - 1 != i) this.buf += this.out(',' + (this.compress ? '' : ' '));\n  }\n};\n\n/**\n * Visit Query.\n */\n\nCompiler.prototype.visitQuery = function(node){\n  var len = node.nodes.length;\n  if (node.predicate) this.buf += this.out(node.predicate + ' ');\n  if (node.type) this.buf += this.out(node.type + (len ? ' and ' : ''));\n  for (var i = 0; i < len; ++i) {\n    this.buf += this.out(this.visit(node.nodes[i]));\n    if (len - 1 != i) this.buf += this.out(' and ');\n  }\n};\n\n/**\n * Visit Feature.\n */\n\nCompiler.prototype.visitFeature = function(node){\n  if (!node.expr) {\n    return node.name;\n  } else if (node.expr.isEmpty) {\n    return '(' + node.name + ')';\n  } else {\n    return '(' + node.name + ':' + (this.compress ? '' : ' ') + this.visit(node.expr) + ')';\n  }\n};\n\n/**\n * Visit Import.\n */\n\nCompiler.prototype.visitImport = function(imported){\n  this.buf += this.out('@import ' + this.visit(imported.path) + ';\\n', imported);\n};\n\n/**\n * Visit Atrule.\n */\n\nCompiler.prototype.visitAtrule = function(atrule){\n  var newline = this.compress ? '' : '\\n';\n\n  this.buf += this.out(this.indent + '@' + atrule.type, atrule);\n\n  if (atrule.val) this.buf += this.out(' ' + atrule.val.trim());\n\n  if (atrule.block) {\n    if (atrule.hasOnlyProperties) {\n      this.visit(atrule.block);\n    } else {\n      this.buf += this.out(this.compress ? '{' : ' {\\n');\n      ++this.indents;\n      this.visit(atrule.block);\n      --this.indents;\n      this.buf += this.out(this.indent + '}' + newline);\n    }\n  } else {\n    this.buf += this.out(';' + newline);\n  }\n};\n\n/**\n * Visit Supports.\n */\n\nCompiler.prototype.visitSupports = function(node){\n  if (!node.hasOutput) return;\n\n  this.buf += this.out(this.indent + '@supports ', node);\n  this.isCondition = true;\n  this.buf += this.out(this.visit(node.condition));\n  this.isCondition = false;\n  this.buf += this.out(this.compress ? '{' : ' {\\n');\n  ++this.indents;\n  this.visit(node.block);\n  --this.indents;\n  this.buf += this.out(this.indent + '}' + (this.compress ? '' : '\\n'));\n},\n\n/**\n * Visit Comment.\n */\n\nCompiler.prototype.visitComment = function(comment){\n  return this.compress\n    ? comment.suppress\n      ? ''\n      : comment.str\n    : comment.str;\n};\n\n/**\n * Visit Function.\n */\n\nCompiler.prototype.visitFunction = function(fn){\n  return fn.name;\n};\n\n/**\n * Visit Charset.\n */\n\nCompiler.prototype.visitCharset = function(charset){\n  return '@charset ' + this.visit(charset.val) + ';';\n};\n\n/**\n * Visit Namespace.\n */\n\nCompiler.prototype.visitNamespace = function(namespace){\n  return '@namespace '\n    + (namespace.prefix ? this.visit(namespace.prefix) + ' ' : '')\n    + this.visit(namespace.val) + ';';\n};\n\n/**\n * Visit Literal.\n */\n\nCompiler.prototype.visitLiteral = function(lit){\n  var val = lit.val;\n  if (lit.css) val = val.replace(/^  /gm, '');\n  return val;\n};\n\n/**\n * Visit Boolean.\n */\n\nCompiler.prototype.visitBoolean = function(bool){\n  return bool.toString();\n};\n\n/**\n * Visit RGBA.\n */\n\nCompiler.prototype.visitRGBA = function(rgba){\n  return rgba.toString();\n};\n\n/**\n * Visit HSLA.\n */\n\nCompiler.prototype.visitHSLA = function(hsla){\n  return hsla.rgba.toString();\n};\n\n/**\n * Visit Unit.\n */\n\nCompiler.prototype.visitUnit = function(unit){\n  var type = unit.type || ''\n    , n = unit.val\n    , float = n != (n | 0);\n\n  // Compress\n  if (this.compress) {\n    // Always return '0' unless the unit is a percentage or time\n    if ('%' != type && 's' != type && 'ms' != type && 0 == n) return '0';\n    // Omit leading '0' on floats\n    if (float && n < 1 && n > -1) {\n      return n.toString().replace('0.', '.') + type;\n    }\n  }\n\n  return (float ? parseFloat(n.toFixed(15)) : n).toString() + type;\n};\n\n/**\n * Visit Group.\n */\n\nCompiler.prototype.visitGroup = function(group){\n  var stack = this.keyframe ? [] : this.stack\n    , comma = this.compress ? ',' : ',\\n';\n\n  stack.push(group.nodes);\n\n  // selectors\n  if (group.block.hasProperties) {\n    var selectors = utils.compileSelectors.call(this, stack)\n      , len = selectors.length;\n\n    if (len) {\n      if (this.keyframe) comma = this.compress ? ',' : ', ';\n\n      for (var i = 0; i < len; ++i) {\n        var selector = selectors[i]\n          , last = (i == len - 1);\n\n        // keyframe blocks (10%, 20% { ... })\n        if (this.keyframe) selector = i ? selector.trim() : selector;\n\n        this.buf += this.out(selector + (last ? '' : comma), group.nodes[i]);\n      }\n    } else {\n      group.block.lacksRenderedSelectors = true;\n    }\n  }\n\n  // output block\n  this.visit(group.block);\n  stack.pop();\n};\n\n/**\n * Visit Ident.\n */\n\nCompiler.prototype.visitIdent = function(ident){\n  return ident.name;\n};\n\n/**\n * Visit String.\n */\n\nCompiler.prototype.visitString = function(string){\n  return this.isURL\n    ? string.val\n    : string.toString();\n};\n\n/**\n * Visit Null.\n */\n\nCompiler.prototype.visitNull = function(node){\n  return '';\n};\n\n/**\n * Visit Call.\n */\n\nCompiler.prototype.visitCall = function(call){\n  this.isURL = 'url' == call.name;\n  var args = call.args.nodes.map(function(arg){\n    return this.visit(arg);\n  }, this).join(this.compress ? ',' : ', ');\n  if (this.isURL) args = '\"' + args + '\"';\n  this.isURL = false;\n  return call.name + '(' + args + ')';\n};\n\n/**\n * Visit Expression.\n */\n\nCompiler.prototype.visitExpression = function(expr){\n  var buf = []\n    , self = this\n    , len = expr.nodes.length\n    , nodes = expr.nodes.map(function(node){ return self.visit(node); });\n\n  nodes.forEach(function(node, i){\n    var last = i == len - 1;\n    buf.push(node);\n    if ('/' == nodes[i + 1] || '/' == node) return;\n    if (last) return;\n\n    var space = self.isURL || (self.isCondition\n        && (')' == nodes[i + 1] || '(' == node))\n        ? '' : ' ';\n\n    buf.push(expr.isList\n      ? (self.compress ? ',' : ', ')\n      : space);\n  });\n\n  return buf.join('');\n};\n\n/**\n * Visit Arguments.\n */\n\nCompiler.prototype.visitArguments = Compiler.prototype.visitExpression;\n\n/**\n * Visit Property.\n */\n\nCompiler.prototype.visitProperty = function(prop){\n  var val = this.visit(prop.expr).trim()\n    , name = (prop.name || prop.segments.join(''))\n    , arr = [];\n  arr.push(\n    this.out(this.indent),\n    this.out(name + (this.compress ? ':' : ': '), prop),\n    this.out(val, prop.expr),\n    this.out(this.compress ? (this.last ? '' : ';') : ';')\n  );\n  return arr.join('');\n};\n\n/**\n * Debug info.\n */\n\nCompiler.prototype.debugInfo = function(node){\n\n  var path = node.filename == 'stdin' ? 'stdin' : fs.realpathSync(node.filename)\n    , line = (node.nodes && node.nodes.length ? node.nodes[0].lineno : node.lineno) || 1;\n\n  if (this.linenos){\n    this.buf += '\\n/* ' + 'line ' + line + ' : ' + path + ' */\\n';\n  }\n\n  if (this.firebug){\n    // debug info for firebug, the crazy formatting is needed\n    path = 'file\\\\\\:\\\\\\/\\\\\\/' + path.replace(/([.:/\\\\])/g, function(m) {\n      return '\\\\' + (m === '\\\\' ? '\\/' : m)\n    });\n    line = '\\\\00003' + line;\n    this.buf += '\\n@media -stylus-debug-info'\n      + '{filename{font-family:' + path\n      + '}line{font-family:' + line + '}}\\n';\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/saturation.js":"var nodes = require('../nodes')\n  , hsla = require('./hsla')\n  , component = require('./component');\n\n/**\n * Return the saturation component of the given `color`,\n * or set the saturation component to the optional second `value` argument.\n *\n * Examples:\n *\n *    saturation(#00c)\n *    // => 100%\n *\n *    saturation(#00c, 50%)\n *    // => #339\n *\n * @param {RGBA|HSLA} color\n * @param {Unit} [value]\n * @return {Unit|RGBA}\n * @api public\n */\n\nmodule.exports = function saturation(color, value){\n  if (value) {\n    var hslaColor = color.hsla;\n    return hsla(\n      new nodes.Unit(hslaColor.h),\n      value,\n      new nodes.Unit(hslaColor.l),\n      new nodes.Unit(hslaColor.a)\n    )\n  }\n  return component(color, new nodes.String('saturation'));\n};\n\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/selector-exists.js":"var utils = require('../utils');\n\n/**\n * Returns true if the given selector exists.\n *\n * @param {String} sel\n * @return {Boolean}\n * @api public\n */\n\nmodule.exports = function selectorExists(sel) {\n  utils.assertString(sel, 'selector');\n\n  if (!this.__selectorsMap__) {\n    var Normalizer = require('../visitor/normalizer')\n      , visitor = new Normalizer(this.root.clone());\n    visitor.visit(visitor.root);\n\n    this.__selectorsMap__ = visitor.map;\n  }\n\n  return sel.string in this.__selectorsMap__;\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/selector.js":"var utils = require('../utils');\n\n/**\n * Return the current selector or compile\n * selector from a string or a list.\n *\n * @param {String|Expression}\n * @return {String}\n * @api public\n */\n\n(module.exports = function selector(){\n  var stack = this.selectorStack\n    , args = [].slice.call(arguments);\n\n  if (1 == args.length) {\n    var expr = utils.unwrap(args[0])\n      , len = expr.nodes.length;\n\n    // selector('.a')\n    if (1 == len) {\n      utils.assertString(expr.first, 'selector');\n      var SelectorParser = require('../selector-parser')\n        , val = expr.first.string\n        , parsed = new SelectorParser(val).parse().val;\n\n      if (parsed == val) return val;\n\n      stack.push(parse(val));\n    } else if (len > 1) {\n      // selector-list = '.a', '.b', '.c'\n      // selector(selector-list)\n      if (expr.isList) {\n        pushToStack(expr.nodes, stack);\n      // selector('.a' '.b' '.c')\n      } else {\n        stack.push(parse(expr.nodes.map(function(node){\n          utils.assertString(node, 'selector');\n          return node.string;\n        }).join(' ')));\n      }\n    }\n  // selector('.a', '.b', '.c')\n  } else if (args.length > 1) {\n    pushToStack(args, stack);\n  }\n\n  return stack.length ? utils.compileSelectors(stack).join(',') : '&';\n}).raw = true;\n\nfunction pushToStack(selectors, stack) {\n  selectors.forEach(function(sel) {\n    sel = sel.first;\n    utils.assertString(sel, 'selector');\n    stack.push(parse(sel.string));\n  });\n}\n\nfunction parse(selector) {\n  var Parser = new require('../parser')\n    , parser = new Parser(selector)\n    , nodes;\n  parser.state.push('selector-parts');\n  nodes = parser.selector();\n  nodes.forEach(function(node) {\n    node.val = node.segments.map(function(seg){\n      return seg.toString();\n    }).join('');\n  });\n  return nodes;\n}\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/selectors.js":"var nodes = require('../nodes')\n  , Parser = require('../selector-parser');\n\n/**\n * Return a list with raw selectors parts\n * of the current group.\n *\n * For example:\n *\n *    .a, .b\n *      .c\n *        .d\n *          test: selectors() // => '.a,.b', '& .c', '& .d'\n *\n * @return {Expression}\n * @api public\n */\n\nmodule.exports = function selectors(){\n  var stack = this.selectorStack\n    , expr = new nodes.Expression(true);\n\n  if (stack.length) {\n    for (var i = 0; i < stack.length; i++) {\n      var group = stack[i]\n        , nested;\n\n      if (group.length > 1) {\n        expr.push(new nodes.String(group.map(function(selector) {\n          nested = new Parser(selector.val).parse().nested;\n          return (nested && i ? '& ' : '') + selector.val;\n        }).join(',')))\n      } else {\n        var selector = group[0].val\n        nested = new Parser(selector).parse().nested;\n        expr.push(new nodes.String((nested && i ? '& ' : '') + selector));\n      }\n    }\n  } else {\n    expr.push(new nodes.String('&'));\n  }\n  return expr;\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/selector-parser.js":"/*!\n * Stylus - Selector Parser\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\nvar COMBINATORS = ['>', '+', '~'];\n\n/**\n * Initialize a new `SelectorParser`\n * with the given `str` and selectors `stack`.\n *\n * @param {String} str\n * @param {Array} stack\n * @param {Array} parts\n * @api private\n */\n\nvar SelectorParser = module.exports = function SelectorParser(str, stack, parts) {\n  this.str = str;\n  this.stack = stack || [];\n  this.parts = parts || [];\n  this.pos = 0;\n  this.level = 2;\n  this.nested = true;\n  this.ignore = false;\n};\n\n/**\n * Consume the given `len` and move current position.\n *\n * @param {Number} len\n * @api private\n */\n\nSelectorParser.prototype.skip = function(len) {\n  this.str = this.str.substr(len);\n  this.pos += len;\n};\n\n/**\n * Consume spaces.\n */\n\nSelectorParser.prototype.skipSpaces = function() {\n  while (' ' == this.str[0]) this.skip(1);\n};\n\n/**\n * Fetch next token.\n *\n * @return {String}\n * @api private\n */\n\nSelectorParser.prototype.advance = function() {\n  return this.root()\n    || this.relative()\n    || this.initial()\n    || this.escaped()\n    || this.parent()\n    || this.partial()\n    || this.char();\n};\n\n/**\n * '/'\n */\n\nSelectorParser.prototype.root = function() {\n  if (!this.pos && '/' == this.str[0]\n    && 'deep' != this.str.slice(1, 5)) {\n    this.nested = false;\n    this.skip(1);\n  }\n};\n\n/**\n * '../'\n */\n\nSelectorParser.prototype.relative = function(multi) {\n  if ((!this.pos || multi) && '../' == this.str.slice(0, 3)) {\n    this.nested = false;\n    this.skip(3);\n    while (this.relative(true)) this.level++;\n    if (!this.raw) {\n      var ret = this.stack[this.stack.length - this.level];\n      if (ret) {\n        return ret;\n      } else {\n        this.ignore = true;\n      }\n    }\n  }\n};\n\n/**\n * '~/'\n */\n\nSelectorParser.prototype.initial = function() {\n  if (!this.pos && '~' == this.str[0] && '/' == this.str[1]) {\n    this.nested = false;\n    this.skip(2);\n    return this.stack[0];\n  }\n};\n\n/**\n * '\\' ('&' | '^')\n */\n\nSelectorParser.prototype.escaped = function() {\n  if ('\\\\' == this.str[0]) {\n    var char = this.str[1];\n    if ('&' == char || '^' == char) {\n      this.skip(2);\n      return char;\n    }\n  }\n};\n\n/**\n * '&'\n */\n\nSelectorParser.prototype.parent = function() {\n  if ('&' == this.str[0]) {\n    this.nested = false;\n\n    if (!this.pos && (!this.stack.length || this.raw)) {\n      var i = 0;\n      while (' ' == this.str[++i]) ;\n      if (~COMBINATORS.indexOf(this.str[i])) {\n        this.skip(i + 1);\n        return;\n      }\n    }\n\n    this.skip(1);\n    if (!this.raw)\n      return this.stack[this.stack.length - 1];\n  }\n};\n\n/**\n * '^[' range ']'\n */\n\nSelectorParser.prototype.partial = function() {\n  if ('^' == this.str[0] && '[' == this.str[1]) {\n    this.skip(2);\n    this.skipSpaces();\n    var ret = this.range();\n    this.skipSpaces();\n    if (']' != this.str[0]) return '^[';\n    this.nested = false;\n    this.skip(1);\n    if (ret) {\n      return ret;\n    } else {\n      this.ignore = true;\n    }\n  }\n};\n\n/**\n * '-'? 0-9+\n */\n\nSelectorParser.prototype.number = function() {\n  var i =  0, ret = '';\n  if ('-' == this.str[i])\n    ret += this.str[i++];\n\n  while (this.str.charCodeAt(i) >= 48\n    && this.str.charCodeAt(i) <= 57)\n    ret += this.str[i++];\n\n  if (ret) {\n    this.skip(i);\n    return Number(ret);\n  }\n};\n\n/**\n * number ('..' number)?\n */\n\nSelectorParser.prototype.range = function() {\n  var start = this.number()\n    , ret;\n\n  if ('..' == this.str.slice(0, 2)) {\n    this.skip(2);\n    var end = this.number()\n      , len = this.parts.length;\n\n    if (start < 0) start = len + start - 1;\n    if (end < 0) end = len + end - 1;\n\n    if (start > end) {\n      var tmp = start;\n      start = end;\n      end = tmp;\n    }\n\n    if (end < len - 1) {\n      ret = this.parts.slice(start, end + 1).map(function(part) {\n        var selector = new SelectorParser(part, this.stack, this.parts);\n        selector.raw = true;\n        return selector.parse();\n      }, this).map(function(selector) {\n        return (selector.nested ? ' ' : '') + selector.val;\n      }).join('').trim();\n    }\n  } else {\n    ret = this.stack[\n      start < 0 ? this.stack.length + start - 1 : start\n    ];\n  }\n\n  if (ret) {\n    return ret;\n  } else {\n    this.ignore = true;\n  }\n};\n\n/**\n * .+\n */\n\nSelectorParser.prototype.char = function() {\n  var char = this.str[0];\n  this.skip(1);\n  return char;\n};\n\n/**\n * Parses the selector.\n *\n * @return {Object}\n * @api private\n */\n\nSelectorParser.prototype.parse = function() {\n  var val = '';\n  while (this.str.length) {\n    val += this.advance() || '';\n    if (this.ignore) {\n      val = '';\n      break;\n    }\n  }\n  return { val: val.trimRight(), nested: this.nested };\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/shift.js":"var utils = require('../utils');\n\n/**\n * Shift an element from `expr`.\n *\n * @param {Expression} expr\n * @return {Node}\n * @api public\n */\n\n (module.exports = function(expr){\n   expr = utils.unwrap(expr);\n   return expr.nodes.shift();\n }).raw = true;\n\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/split.js":"var utils = require('../utils')\n  , nodes = require('../nodes');\n\n/**\n * Splits the given `val` by `delim`\n *\n * @param {String} delim\n * @param {String|Ident} val\n * @return {Expression}\n * @api public\n */\n\nmodule.exports = function split(delim, val){\n  utils.assertString(delim, 'delimiter');\n  utils.assertString(val, 'val');\n  var splitted = val.string.split(delim.string);\n  var expr = new nodes.Expression();\n  var ItemNode = val instanceof nodes.Ident\n    ? nodes.Ident\n    : nodes.String;\n  for (var i = 0, len = splitted.length; i < len; ++i) {\n    expr.nodes.push(new ItemNode(splitted[i]));\n  }\n  return expr;\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/substr.js":"var utils = require('../utils')\n  , nodes = require('../nodes');\n\n/**\n * Returns substring of the given `val`.\n *\n * @param {String|Ident} val\n * @param {Number} start\n * @param {Number} [length]\n * @return {String|Ident}\n * @api public\n */\n\nmodule.exports = function substr(val, start, length){\n  utils.assertString(val, 'val');\n  utils.assertType(start, 'unit', 'start');\n  length = length && length.val;\n  var res = val.string.substr(start.val, length);\n  return val instanceof nodes.Ident\n      ? new nodes.Ident(res)\n      : new nodes.String(res);\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/slice.js":"var utils = require('../utils'),\n    nodes = require('../nodes');\n\n/**\n * This is a heler function for the slice method\n *\n * @param {String|Ident} vals\n * @param {Unit} start [0]\n * @param {Unit} end [vals.length]\n * @return {String|Literal|Null}\n * @api public\n*/\n(module.exports = function slice(val, start, end) {\n  start = start && start.nodes[0].val;\n  end = end && end.nodes[0].val;\n\n  val = utils.unwrap(val).nodes;\n\n  if (val.length > 1) {\n    return utils.coerce(val.slice(start, end), true);\n  }\n\n  var result = val[0].string.slice(start, end);\n\n  return val[0] instanceof nodes.Ident\n    ? new nodes.Ident(result)\n    : new nodes.String(result);\n}).raw = true;\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/tan.js":"var utils = require('../utils')\n  , nodes = require('../nodes');\n\n/**\n * Return the tangent of the given `angle`.\n *\n * @param {Unit} angle\n * @return {Unit}\n * @api public\n */\n\nmodule.exports = function tan(angle) {\n  utils.assertType(angle, 'unit', 'angle');\n\n  var radians = angle.val;\n\n  if (angle.type === 'deg') {\n    radians *= Math.PI / 180;\n  }\n\n  var m = Math.pow(10, 9);\n\n  var sin = Math.round(Math.sin(radians) * m) / m\n    , cos = Math.round(Math.cos(radians) * m) / m\n    , tan = Math.round(m * sin / cos ) / m;\n\n  return new nodes.Unit(tan, '');\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/trace.js":"var nodes = require('../nodes');\n\n/**\n * Output stack trace.\n *\n * @api public\n */\n\nmodule.exports = function trace(){\n  console.log(this.stack);\n  return nodes.null;\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/transparentify.js":"var utils = require('../utils')\n  , nodes = require('../nodes');\n\n/**\n * Returns the transparent version of the given `top` color,\n * as if it was blend over the given `bottom` color.\n *\n * Examples:\n *\n *     transparentify(#808080)\n *     => rgba(0,0,0,0.5)\n *\n *     transparentify(#414141, #000)\n *     => rgba(255,255,255,0.25)\n *\n *     transparentify(#91974C, #F34949, 0.5)\n *     => rgba(47,229,79,0.5)\n *\n * @param {RGBA|HSLA} top\n * @param {RGBA|HSLA} [bottom=#fff]\n * @param {Unit} [alpha]\n * @return {RGBA}\n * @api public\n */\n\nmodule.exports = function transparentify(top, bottom, alpha){\n  utils.assertColor(top);\n  top = top.rgba;\n  // Handle default arguments\n  bottom = bottom || new nodes.RGBA(255, 255, 255, 1);\n  if (!alpha && bottom && !bottom.rgba) {\n    alpha = bottom;\n    bottom = new nodes.RGBA(255, 255, 255, 1);\n  }\n  utils.assertColor(bottom);\n  bottom = bottom.rgba;\n  var bestAlpha = ['r', 'g', 'b'].map(function(channel){\n    return (top[channel] - bottom[channel]) / ((0 < (top[channel] - bottom[channel]) ? 255 : 0) - bottom[channel]);\n  }).sort(function(a, b){return a < b;})[0];\n  if (alpha) {\n    utils.assertType(alpha, 'unit', 'alpha');\n    if ('%' == alpha.type) {\n      bestAlpha = alpha.val / 100;\n    } else if (!alpha.type) {\n      bestAlpha = alpha = alpha.val;\n    }\n  }\n  bestAlpha = Math.max(Math.min(bestAlpha, 1), 0);\n  // Calculate the resulting color\n  function processChannel(channel) {\n    if (0 == bestAlpha) {\n      return bottom[channel]\n    } else {\n      return bottom[channel] + (top[channel] - bottom[channel]) / bestAlpha\n    }\n  }\n  return new nodes.RGBA(\n    processChannel('r'),\n    processChannel('g'),\n    processChannel('b'),\n    Math.round(bestAlpha * 100) / 100\n  );\n}\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/type.js":"var utils = require('../utils');\n\n/**\n * Return type of `node`.\n *\n * Examples:\n * \n *    type(12)\n *    // => 'unit'\n *\n *    type(#fff)\n *    // => 'color'\n *\n *    type(type)\n *    // => 'function'\n *\n *    type(unbound)\n *    typeof(unbound)\n *    type-of(unbound)\n *    // => 'ident'\n *\n * @param {Node} node\n * @return {String}\n * @api public\n */\n\nmodule.exports = function type(node){\n  utils.assertPresent(node, 'expression');\n  return node.nodeName;\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/unit.js":"var utils = require('../utils')\n  , nodes = require('../nodes');\n\n/**\n * Assign `type` to the given `unit` or return `unit`'s type.\n *\n * @param {Unit} unit\n * @param {String|Ident} type\n * @return {Unit}\n * @api public\n */\n\nmodule.exports = function unit(unit, type){\n  utils.assertType(unit, 'unit', 'unit');\n\n  // Assign\n  if (type) {\n    utils.assertString(type, 'type');\n    return new nodes.Unit(unit.val, type.string);\n  } else {\n    return unit.type || '';\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/unquote.js":"var utils = require('../utils')\n  , nodes = require('../nodes');\n\n/**\n * Unquote the given `string`.\n *\n * Examples:\n *\n *    unquote(\"sans-serif\")\n *    // => sans-serif\n *\n *    unquote(sans-serif)\n *    // => sans-serif\n *\n * @param {String|Ident} string\n * @return {Literal}\n * @api public\n */\n\nmodule.exports = function unquote(string){\n  utils.assertString(string, 'string');\n  return new nodes.Literal(string.string);\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/unshift.js":"var utils = require('../utils');\n\n/**\n * Unshift the given args to `expr`.\n *\n * @param {Expression} expr\n * @param {Node} ...\n * @return {Unit}\n * @api public\n */\n\n(module.exports = function(expr){\n  expr = utils.unwrap(expr);\n  for (var i = 1, len = arguments.length; i < len; ++i) {\n    expr.nodes.unshift(utils.unwrap(arguments[i]));\n  }\n  return expr.nodes.length;\n}).raw = true;\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/use.js":"var utils = require('../utils')\n  , path = require('path');\n\n/**\n*  Use the given `plugin`\n*  \n*  Examples:\n*\n*     use(\"plugins/add.js\")\n*\n*     width add(10, 100)\n*     // => width: 110\n*/\n\nmodule.exports = function use(plugin, options){\n  utils.assertString(plugin, 'plugin');\n\n  if (options) {\n    utils.assertType(options, 'object', 'options');\n    options = parseObject(options);\n  }\n\n  // lookup\n  plugin = plugin.string;\n  var found = utils.lookup(plugin, this.options.paths, this.options.filename);\n  if (!found) throw new Error('failed to locate plugin file \"' + plugin + '\"');\n\n  // use\n  var fn = require(path.resolve(found));\n  if ('function' != typeof fn) {\n    throw new Error('plugin \"' + plugin + '\" does not export a function');\n  }\n  this.renderer.use(fn(options || this.options));\n};\n\n/**\n * Attempt to parse object node to the javascript object.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction parseObject(obj){\n  obj = obj.vals;\n  for (var key in obj) {\n    var nodes = obj[key].nodes[0].nodes;\n    if (nodes && nodes.length) {\n      obj[key] = [];\n      for (var i = 0, len = nodes.length; i < len; ++i) {\n        obj[key].push(convert(nodes[i]));\n      }\n    } else {\n      obj[key] = convert(obj[key].first);\n    }\n  }\n  return obj;\n\n  function convert(node){\n    switch (node.nodeName) {\n      case 'object':\n        return parseObject(node);\n      case 'boolean':\n        return node.isTrue;\n      case 'unit':\n        return node.type ? node.toString() : +node.val;\n      case 'string':\n      case 'literal':\n        return node.val;\n      default:\n        return node.toString();\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/warn.js":"var utils = require('../utils')\n  , nodes = require('../nodes');\n\n/**\n * Warn with the given `msg` prefixed by \"Warning: \".\n *\n * @param {String} msg\n * @api public\n */\n\nmodule.exports = function warn(msg){\n  utils.assertType(msg, 'string', 'msg');\n  console.warn('Warning: %s', msg.val);\n  return nodes.null;\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/math-prop.js":"var nodes = require('../nodes');\n\n/**\n * Get Math `prop`.\n *\n * @param {String} prop\n * @return {Unit}\n * @api private\n */\n\nmodule.exports = function math(prop){\n  return new nodes.Unit(Math[prop.string]);\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/functions/prefix-classes.js":"var utils = require('../utils');\n\n/**\n * Prefix css classes in a block\n *\n * @param {String} prefix\n * @param {Block} block\n * @return {Block}\n * @api private\n */\n\nmodule.exports = function prefixClasses(prefix, block){\n  utils.assertString(prefix, 'prefix');\n  utils.assertType(block, 'block', 'block');\n\n  var _prefix = this.prefix;\n\n  this.options.prefix = this.prefix = prefix.string;\n  block = this.visit(block);\n  this.options.prefix = this.prefix = _prefix;\n  return block;\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/colors.js":"\n/*!\n * Stylus - colors\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\nmodule.exports = {\n    aliceblue: [240, 248, 255, 1]\n  , antiquewhite: [250, 235, 215, 1]\n  , aqua: [0, 255, 255, 1]\n  , aquamarine: [127, 255, 212, 1]\n  , azure: [240, 255, 255, 1]\n  , beige: [245, 245, 220, 1]\n  , bisque: [255, 228, 196, 1]\n  , black: [0, 0, 0, 1]\n  , blanchedalmond: [255, 235, 205, 1]\n  , blue: [0, 0, 255, 1]\n  , blueviolet: [138, 43, 226, 1]\n  , brown: [165, 42, 42, 1]\n  , burlywood: [222, 184, 135, 1]\n  , cadetblue: [95, 158, 160, 1]\n  , chartreuse: [127, 255, 0, 1]\n  , chocolate: [210, 105, 30, 1]\n  , coral: [255, 127, 80, 1]\n  , cornflowerblue: [100, 149, 237, 1]\n  , cornsilk: [255, 248, 220, 1]\n  , crimson: [220, 20, 60, 1]\n  , cyan: [0, 255, 255, 1]\n  , darkblue: [0, 0, 139, 1]\n  , darkcyan: [0, 139, 139, 1]\n  , darkgoldenrod: [184, 134, 11, 1]\n  , darkgray: [169, 169, 169, 1]\n  , darkgreen: [0, 100, 0, 1]\n  , darkgrey: [169, 169, 169, 1]\n  , darkkhaki: [189, 183, 107, 1]\n  , darkmagenta: [139, 0, 139, 1]\n  , darkolivegreen: [85, 107, 47, 1]\n  , darkorange: [255, 140, 0, 1]\n  , darkorchid: [153, 50, 204, 1]\n  , darkred: [139, 0, 0, 1]\n  , darksalmon: [233, 150, 122, 1]\n  , darkseagreen: [143, 188, 143, 1]\n  , darkslateblue: [72, 61, 139, 1]\n  , darkslategray: [47, 79, 79, 1]\n  , darkslategrey: [47, 79, 79, 1]\n  , darkturquoise: [0, 206, 209, 1]\n  , darkviolet: [148, 0, 211, 1]\n  , deeppink: [255, 20, 147, 1]\n  , deepskyblue: [0, 191, 255, 1]\n  , dimgray: [105, 105, 105, 1]\n  , dimgrey: [105, 105, 105, 1]\n  , dodgerblue: [30, 144, 255, 1]\n  , firebrick: [178, 34, 34, 1]\n  , floralwhite: [255, 250, 240, 1]\n  , forestgreen: [34, 139, 34, 1]\n  , fuchsia: [255, 0, 255, 1]\n  , gainsboro: [220, 220, 220, 1]\n  , ghostwhite: [248, 248, 255, 1]\n  , gold: [255, 215, 0, 1]\n  , goldenrod: [218, 165, 32, 1]\n  , gray: [128, 128, 128, 1]\n  , green: [0, 128, 0, 1]\n  , greenyellow: [173, 255, 47, 1]\n  , grey: [128, 128, 128, 1]\n  , honeydew: [240, 255, 240, 1]\n  , hotpink: [255, 105, 180, 1]\n  , indianred: [205, 92, 92, 1]\n  , indigo: [75, 0, 130, 1]\n  , ivory: [255, 255, 240, 1]\n  , khaki: [240, 230, 140, 1]\n  , lavender: [230, 230, 250, 1]\n  , lavenderblush: [255, 240, 245, 1]\n  , lawngreen: [124, 252, 0, 1]\n  , lemonchiffon: [255, 250, 205, 1]\n  , lightblue: [173, 216, 230, 1]\n  , lightcoral: [240, 128, 128, 1]\n  , lightcyan: [224, 255, 255, 1]\n  , lightgoldenrodyellow: [250, 250, 210, 1]\n  , lightgray: [211, 211, 211, 1]\n  , lightgreen: [144, 238, 144, 1]\n  , lightgrey: [211, 211, 211, 1]\n  , lightpink: [255, 182, 193, 1]\n  , lightsalmon: [255, 160, 122, 1]\n  , lightseagreen: [32, 178, 170, 1]\n  , lightskyblue: [135, 206, 250, 1]\n  , lightslategray: [119, 136, 153, 1]\n  , lightslategrey: [119, 136, 153, 1]\n  , lightsteelblue: [176, 196, 222, 1]\n  , lightyellow: [255, 255, 224, 1]\n  , lime: [0, 255, 0, 1]\n  , limegreen: [50, 205, 50, 1]\n  , linen: [250, 240, 230, 1]\n  , magenta: [255, 0, 255, 1]\n  , maroon: [128, 0, 0, 1]\n  , mediumaquamarine: [102, 205, 170, 1]\n  , mediumblue: [0, 0, 205, 1]\n  , mediumorchid: [186, 85, 211, 1]\n  , mediumpurple: [147, 112, 219, 1]\n  , mediumseagreen: [60, 179, 113, 1]\n  , mediumslateblue: [123, 104, 238, 1]\n  , mediumspringgreen: [0, 250, 154, 1]\n  , mediumturquoise: [72, 209, 204, 1]\n  , mediumvioletred: [199, 21, 133, 1]\n  , midnightblue: [25, 25, 112, 1]\n  , mintcream: [245, 255, 250, 1]\n  , mistyrose: [255, 228, 225, 1]\n  , moccasin: [255, 228, 181, 1]\n  , navajowhite: [255, 222, 173, 1]\n  , navy: [0, 0, 128, 1]\n  , oldlace: [253, 245, 230, 1]\n  , olive: [128, 128, 0, 1]\n  , olivedrab: [107, 142, 35, 1]\n  , orange: [255, 165, 0, 1]\n  , orangered: [255, 69, 0, 1]\n  , orchid: [218, 112, 214, 1]\n  , palegoldenrod: [238, 232, 170, 1]\n  , palegreen: [152, 251, 152, 1]\n  , paleturquoise: [175, 238, 238, 1]\n  , palevioletred: [219, 112, 147, 1]\n  , papayawhip: [255, 239, 213, 1]\n  , peachpuff: [255, 218, 185, 1]\n  , peru: [205, 133, 63, 1]\n  , pink: [255, 192, 203, 1]\n  , plum: [221, 160, 221, 1]\n  , powderblue: [176, 224, 230, 1]\n  , purple: [128, 0, 128, 1]\n  , red: [255, 0, 0, 1]\n  , rosybrown: [188, 143, 143, 1]\n  , royalblue: [65, 105, 225, 1]\n  , saddlebrown: [139, 69, 19, 1]\n  , salmon: [250, 128, 114, 1]\n  , sandybrown: [244, 164, 96, 1]\n  , seagreen: [46, 139, 87, 1]\n  , seashell: [255, 245, 238, 1]\n  , sienna: [160, 82, 45, 1]\n  , silver: [192, 192, 192, 1]\n  , skyblue: [135, 206, 235, 1]\n  , slateblue: [106, 90, 205, 1]\n  , slategray: [112, 128, 144, 1]\n  , slategrey: [112, 128, 144, 1]\n  , snow: [255, 250, 250, 1]\n  , springgreen: [0, 255, 127, 1]\n  , steelblue: [70, 130, 180, 1]\n  , tan: [210, 180, 140, 1]\n  , teal: [0, 128, 128, 1]\n  , thistle: [216, 191, 216, 1]\n  , tomato: [255, 99, 71, 1]\n  , transparent: [0, 0, 0, 0]\n  , turquoise: [64, 224, 208, 1]\n  , violet: [238, 130, 238, 1]\n  , wheat: [245, 222, 179, 1]\n  , white: [255, 255, 255, 1]\n  , whitesmoke: [245, 245, 245, 1]\n  , yellow: [255, 255, 0, 1]\n  , yellowgreen: [154, 205, 50, 1]\n  , rebeccapurple: [102, 51, 153, 1]\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/root.js":"\n/*!\n * Stylus - Root\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a new `Root` node.\n *\n * @api public\n */\n\nvar Root = module.exports = function Root(){\n  this.nodes = [];\n};\n\n/**\n * Inherit from `Node.prototype`.\n */\n\nRoot.prototype.__proto__ = Node.prototype;\n\n/**\n * Push a `node` to this block.\n *\n * @param {Node} node\n * @api public\n */\n\nRoot.prototype.push = function(node){\n  this.nodes.push(node);\n};\n\n/**\n * Unshift a `node` to this block.\n *\n * @param {Node} node\n * @api public\n */\n\nRoot.prototype.unshift = function(node){\n  this.nodes.unshift(node);\n};\n\n/**\n * Return a clone of this node.\n *\n * @return {Node}\n * @api public\n */\n\nRoot.prototype.clone = function(){\n  var clone = new Root();\n  clone.lineno = this.lineno;\n  clone.column = this.column;\n  clone.filename = this.filename;\n  this.nodes.forEach(function(node){\n    clone.push(node.clone(clone, clone));\n  });\n  return clone;\n};\n\n/**\n * Return \"root\".\n *\n * @return {String}\n * @api public\n */\n\nRoot.prototype.toString = function(){\n  return '[Root]';\n};\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nRoot.prototype.toJSON = function(){\n  return {\n    __type: 'Root',\n    nodes: this.nodes,\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/null.js":"\n/*!\n * Stylus - Null\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node')\n  , nodes = require('./');\n\n/**\n * Initialize a new `Null` node.\n *\n * @api public\n */\n\nvar Null = module.exports = function Null(){};\n\n/**\n * Inherit from `Node.prototype`.\n */\n\nNull.prototype.__proto__ = Node.prototype;\n\n/**\n * Return 'Null'.\n *\n * @return {String}\n * @api public\n */\n\nNull.prototype.inspect = \nNull.prototype.toString = function(){\n  return 'null';\n};\n\n/**\n * Return false.\n *\n * @return {Boolean}\n * @api public\n */\n\nNull.prototype.toBoolean = function(){\n  return nodes.false;\n};\n\n/**\n * Check if the node is a null node.\n *\n * @return {Boolean}\n * @api public\n */\n\nNull.prototype.__defineGetter__('isNull', function(){\n  return true;\n});\n\n/**\n * Return hash.\n *\n * @return {String}\n * @api public\n */\n\nNull.prototype.__defineGetter__('hash', function(){\n  return null;\n});\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nNull.prototype.toJSON = function(){\n  return {\n    __type: 'Null',\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/each.js":"\n/*!\n * Stylus - Each\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node')\n  , nodes = require('./');\n\n/**\n * Initialize a new `Each` node with the given `val` name,\n * `key` name, `expr`, and `block`.\n *\n * @param {String} val\n * @param {String} key\n * @param {Expression} expr\n * @param {Block} block\n * @api public\n */\n\nvar Each = module.exports = function Each(val, key, expr, block){\n  Node.call(this);\n  this.val = val;\n  this.key = key;\n  this.expr = expr;\n  this.block = block;\n};\n\n/**\n * Inherit from `Node.prototype`.\n */\n\nEach.prototype.__proto__ = Node.prototype;\n\n/**\n * Return a clone of this node.\n * \n * @return {Node}\n * @api public\n */\n\nEach.prototype.clone = function(parent){\n  var clone = new Each(this.val, this.key);\n  clone.expr = this.expr.clone(parent, clone);\n  clone.block = this.block.clone(parent, clone);\n  clone.lineno = this.lineno;\n  clone.column = this.column;\n  clone.filename = this.filename;\n  return clone;\n};\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nEach.prototype.toJSON = function(){\n  return {\n    __type: 'Each',\n    val: this.val,\n    key: this.key,\n    expr: this.expr,\n    block: this.block,\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/if.js":"\n/*!\n * Stylus - If\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a new `If` with the given `cond`.\n *\n * @param {Expression} cond\n * @param {Boolean|Block} negate, block\n * @api public\n */\n\nvar If = module.exports = function If(cond, negate){\n  Node.call(this);\n  this.cond = cond;\n  this.elses = [];\n  if (negate && negate.nodeName) {\n    this.block = negate;\n  } else {\n    this.negate = negate;\n  }\n};\n\n/**\n * Inherit from `Node.prototype`.\n */\n\nIf.prototype.__proto__ = Node.prototype;\n\n/**\n * Return a clone of this node.\n * \n * @return {Node}\n * @api public\n */\n\nIf.prototype.clone = function(parent){\n  var clone = new If();\n  clone.cond = this.cond.clone(parent, clone);\n  clone.block = this.block.clone(parent, clone);\n  clone.elses = this.elses.map(function(node){ return node.clone(parent, clone); });\n  clone.negate = this.negate;\n  clone.postfix = this.postfix;\n  clone.lineno = this.lineno;\n  clone.column = this.column;\n  clone.filename = this.filename;\n  return clone;\n};\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nIf.prototype.toJSON = function(){\n  return {\n    __type: 'If',\n    cond: this.cond,\n    block: this.block,\n    elses: this.elses,\n    negate: this.negate,\n    postfix: this.postfix,\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/call.js":"\n/*!\n * Stylus - Call\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a new `Call` with `name` and `args`.\n *\n * @param {String} name\n * @param {Expression} args\n * @api public\n */\n\nvar Call = module.exports = function Call(name, args){\n  Node.call(this);\n  this.name = name;\n  this.args = args;\n};\n\n/**\n * Inherit from `Node.prototype`.\n */\n\nCall.prototype.__proto__ = Node.prototype;\n\n/**\n * Return a clone of this node.\n * \n * @return {Node}\n * @api public\n */\n\nCall.prototype.clone = function(parent){\n  var clone = new Call(this.name);\n  clone.args = this.args.clone(parent, clone);\n  if (this.block) clone.block = this.block.clone(parent, clone);\n  clone.lineno = this.lineno;\n  clone.column = this.column;\n  clone.filename = this.filename;\n  return clone;\n};\n\n/**\n * Return <name>(param1, param2, ...).\n *\n * @return {String}\n * @api public\n */\n\nCall.prototype.toString = function(){\n  var args = this.args.nodes.map(function(node) {\n    var str = node.toString();\n    return str.slice(1, str.length - 1);\n  }).join(', ');\n\n  return this.name + '(' + args + ')';\n};\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nCall.prototype.toJSON = function(){\n  var json = {\n    __type: 'Call',\n    name: this.name,\n    args: this.args,\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename\n  };\n  if (this.block) json.block = this.block;\n  return json;\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/unaryop.js":"\n/*!\n * Stylus - UnaryOp\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a new `UnaryOp` with `op`, and `expr`.\n *\n * @param {String} op\n * @param {Node} expr\n * @api public\n */\n\nvar UnaryOp = module.exports = function UnaryOp(op, expr){\n  Node.call(this);\n  this.op = op;\n  this.expr = expr;\n};\n\n/**\n * Inherit from `Node.prototype`.\n */\n\nUnaryOp.prototype.__proto__ = Node.prototype;\n\n/**\n * Return a clone of this node.\n * \n * @return {Node}\n * @api public\n */\n\nUnaryOp.prototype.clone = function(parent){\n  var clone = new UnaryOp(this.op);\n  clone.expr = this.expr.clone(parent, clone);\n  clone.lineno = this.lineno;\n  clone.column = this.column;\n  clone.filename = this.filename;\n  return clone;\n};\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nUnaryOp.prototype.toJSON = function(){\n  return {\n    __type: 'UnaryOp',\n    op: this.op,\n    expr: this.expr,\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/binop.js":"\n/*!\n * Stylus - BinOp\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a new `BinOp` with `op`, `left` and `right`.\n *\n * @param {String} op\n * @param {Node} left\n * @param {Node} right\n * @api public\n */\n\nvar BinOp = module.exports = function BinOp(op, left, right){\n  Node.call(this);\n  this.op = op;\n  this.left = left;\n  this.right = right;\n};\n\n/**\n * Inherit from `Node.prototype`.\n */\n\nBinOp.prototype.__proto__ = Node.prototype;\n\n/**\n * Return a clone of this node.\n * \n * @return {Node}\n * @api public\n */\n\nBinOp.prototype.clone = function(parent){\n  var clone = new BinOp(this.op);\n  clone.left = this.left.clone(parent, clone);\n  clone.right = this.right && this.right.clone(parent, clone);\n  clone.lineno = this.lineno;\n  clone.column = this.column;\n  clone.filename = this.filename;\n  if (this.val) clone.val = this.val.clone(parent, clone);\n  return clone;\n};\n\n/**\n * Return <left> <op> <right>\n *\n * @return {String}\n * @api public\n */\nBinOp.prototype.toString = function() {\n  return this.left.toString() + ' ' + this.op + ' ' + this.right.toString();\n};\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nBinOp.prototype.toJSON = function(){\n  var json = {\n    __type: 'BinOp',\n    left: this.left,\n    right: this.right,\n    op: this.op,\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename\n  };\n  if (this.val) json.val = this.val;\n  return json;\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/ternary.js":"\n/*!\n * Stylus - Ternary\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a new `Ternary` with `cond`, `trueExpr` and `falseExpr`.\n *\n * @param {Expression} cond\n * @param {Expression} trueExpr\n * @param {Expression} falseExpr\n * @api public\n */\n\nvar Ternary = module.exports = function Ternary(cond, trueExpr, falseExpr){\n  Node.call(this);\n  this.cond = cond;\n  this.trueExpr = trueExpr;\n  this.falseExpr = falseExpr;\n};\n\n/**\n * Inherit from `Node.prototype`.\n */\n\nTernary.prototype.__proto__ = Node.prototype;\n\n/**\n * Return a clone of this node.\n * \n * @return {Node}\n * @api public\n */\n\nTernary.prototype.clone = function(parent){\n  var clone = new Ternary();\n  clone.cond = this.cond.clone(parent, clone);\n  clone.trueExpr = this.trueExpr.clone(parent, clone);\n  clone.falseExpr = this.falseExpr.clone(parent, clone);\n  clone.lineno = this.lineno;\n  clone.column = this.column;\n  clone.filename = this.filename;\n  return clone;\n};\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nTernary.prototype.toJSON = function(){\n  return {\n    __type: 'Ternary',\n    cond: this.cond,\n    trueExpr: this.trueExpr,\n    falseExpr: this.falseExpr,\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/block.js":"\n/*!\n * Stylus - Block\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a new `Block` node with `parent` Block.\n *\n * @param {Block} parent\n * @api public\n */\n\nvar Block = module.exports = function Block(parent, node){\n  Node.call(this);\n  this.nodes = [];\n  this.parent = parent;\n  this.node = node;\n  this.scope = true;\n};\n\n/**\n * Inherit from `Node.prototype`.\n */\n\nBlock.prototype.__proto__ = Node.prototype;\n\n/**\n * Check if this block has properties..\n *\n * @return {Boolean}\n * @api public\n */\n\nBlock.prototype.__defineGetter__('hasProperties', function(){\n  for (var i = 0, len = this.nodes.length; i < len; ++i) {\n    if ('property' == this.nodes[i].nodeName) {\n      return true;\n    }\n  }\n});\n\n/**\n * Check if this block has @media nodes.\n *\n * @return {Boolean}\n * @api public\n */\n\nBlock.prototype.__defineGetter__('hasMedia', function(){\n  for (var i = 0, len = this.nodes.length; i < len; ++i) {\n    var nodeName = this.nodes[i].nodeName;\n    if ('media' == nodeName) {\n      return true;\n    }\n  }\n  return false;\n});\n\n/**\n * Check if this block is empty.\n *\n * @return {Boolean}\n * @api public\n */\n\nBlock.prototype.__defineGetter__('isEmpty', function(){\n  return !this.nodes.length;\n});\n\n/**\n * Return a clone of this node.\n * \n * @return {Node}\n * @api public\n */\n\nBlock.prototype.clone = function(parent, node){\n  parent = parent || this.parent;\n  var clone = new Block(parent, node || this.node);\n  clone.lineno = this.lineno;\n  clone.column = this.column;\n  clone.filename = this.filename;\n  clone.scope = this.scope;\n  this.nodes.forEach(function(node){\n    clone.push(node.clone(clone, clone));\n  });\n  return clone;\n};\n\n/**\n * Push a `node` to this block.\n *\n * @param {Node} node\n * @api public\n */\n\nBlock.prototype.push = function(node){\n  this.nodes.push(node);\n};\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nBlock.prototype.toJSON = function(){\n  return {\n    __type: 'Block',\n    // parent: this.parent,\n    // node: this.node,\n    scope: this.scope,\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename,\n    nodes: this.nodes\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/unit.js":"\n/*!\n * Stylus - Unit\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node')\n  , nodes = require('./');\n\n/**\n * Unit conversion table.\n */\n\nvar FACTOR_TABLE = {\n  'mm': {val: 1, label: 'mm'},\n  'cm': {val: 10, label: 'mm'},\n  'in': {val: 25.4, label: 'mm'},\n  'pt': {val: 25.4/72, label: 'mm'},\n  'ms': {val: 1, label: 'ms'},\n  's': {val: 1000, label: 'ms'},\n  'Hz': {val: 1, label: 'Hz'},\n  'kHz': {val: 1000, label: 'Hz'}\n};\n\n/**\n * Initialize a new `Unit` with the given `val` and unit `type`\n * such as \"px\", \"pt\", \"in\", etc.\n *\n * @param {String} val\n * @param {String} type\n * @api public\n */\n\nvar Unit = module.exports = function Unit(val, type){\n  Node.call(this);\n  this.val = val;\n  this.type = type;\n};\n\n/**\n * Inherit from `Node.prototype`.\n */\n\nUnit.prototype.__proto__ = Node.prototype;\n\n/**\n * Return Boolean based on the unit value.\n *\n * @return {Boolean}\n * @api public\n */\n\nUnit.prototype.toBoolean = function(){\n  return nodes.Boolean(this.type\n      ? true\n      : this.val);\n};\n\n/**\n * Return unit string.\n *\n * @return {String}\n * @api public\n */\n\nUnit.prototype.toString = function(){\n  return this.val + (this.type || '');\n};\n\n/**\n * Return a clone of this node.\n *\n * @return {Node}\n * @api public\n */\n\nUnit.prototype.clone = function(){\n  var clone = new Unit(this.val, this.type);\n  clone.lineno = this.lineno;\n  clone.column = this.column;\n  clone.filename = this.filename;\n  return clone;\n};\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nUnit.prototype.toJSON = function(){\n  return {\n    __type: 'Unit',\n    val: this.val,\n    type: this.type,\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename\n  };\n};\n\n/**\n * Operate on `right` with the given `op`.\n *\n * @param {String} op\n * @param {Node} right\n * @return {Node}\n * @api public\n */\n\nUnit.prototype.operate = function(op, right){\n  var type = this.type || right.first.type;\n\n  // swap color\n  if ('rgba' == right.nodeName || 'hsla' == right.nodeName) {\n    return right.operate(op, this);\n  }\n\n  // operate\n  if (this.shouldCoerce(op)) {\n    right = right.first;\n    // percentages\n    if ('%' != this.type && ('-' == op || '+' == op) && '%' == right.type) {\n      right = new Unit(this.val * (right.val / 100), '%');\n    } else {\n      right = this.coerce(right);\n    }\n\n    switch (op) {\n      case '-':\n        return new Unit(this.val - right.val, type);\n      case '+':\n        // keyframes interpolation\n        type = type || (right.type == '%' && right.type);\n        return new Unit(this.val + right.val, type);\n      case '/':\n        return new Unit(this.val / right.val, type);\n      case '*':\n        return new Unit(this.val * right.val, type);\n      case '%':\n        return new Unit(this.val % right.val, type);\n      case '**':\n        return new Unit(Math.pow(this.val, right.val), type);\n      case '..':\n      case '...':\n        var start = this.val\n          , end = right.val\n          , expr = new nodes.Expression\n          , inclusive = '..' == op;\n        if (start < end) {\n          do {\n            expr.push(new nodes.Unit(start));\n          } while (inclusive ? ++start <= end : ++start < end);\n        } else {\n          do {\n            expr.push(new nodes.Unit(start));\n          } while (inclusive ? --start >= end : --start > end);\n        }\n        return expr;\n    }\n  }\n\n  return Node.prototype.operate.call(this, op, right);\n};\n\n/**\n * Coerce `other` unit to the same type as `this` unit.\n *\n * Supports:\n *\n *    mm -> cm | in\n *    cm -> mm | in\n *    in -> mm | cm\n *\n *    ms -> s\n *    s  -> ms\n *\n *    Hz  -> kHz\n *    kHz -> Hz\n *\n * @param {Unit} other\n * @return {Unit}\n * @api public\n */\n\nUnit.prototype.coerce = function(other){\n  if ('unit' == other.nodeName) {\n    var a = this\n      , b = other\n      , factorA = FACTOR_TABLE[a.type]\n      , factorB = FACTOR_TABLE[b.type];\n\n    if (factorA && factorB && (factorA.label == factorB.label)) {\n      var bVal = b.val * (factorB.val / factorA.val);\n      return new nodes.Unit(bVal, a.type);\n    } else {\n      return new nodes.Unit(b.val, a.type);\n    }\n  } else if ('string' == other.nodeName) {\n    // keyframes interpolation\n    if ('%' == other.val) return new nodes.Unit(0, '%');\n    var val = parseFloat(other.val);\n    if (isNaN(val)) Node.prototype.coerce.call(this, other);\n    return new nodes.Unit(val);\n  } else {\n    return Node.prototype.coerce.call(this, other);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/string.js":"/*!\n * Stylus - String\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node')\n  , sprintf = require('../functions').s\n  , utils = require('../utils')\n  , nodes = require('./');\n\n/**\n * Initialize a new `String` with the given `val`.\n *\n * @param {String} val\n * @param {String} quote\n * @api public\n */\n\nvar String = module.exports = function String(val, quote){\n  Node.call(this);\n  this.val = val;\n  this.string = val;\n  this.prefixed = false;\n  if (typeof quote !== 'string') {\n    this.quote = \"'\";\n  } else {\n    this.quote = quote;\n  }\n};\n\n/**\n * Inherit from `Node.prototype`.\n */\n\nString.prototype.__proto__ = Node.prototype;\n\n/**\n * Return quoted string.\n *\n * @return {String}\n * @api public\n */\n\nString.prototype.toString = function(){\n  return this.quote + this.val + this.quote;\n};\n\n/**\n * Return a clone of this node.\n * \n * @return {Node}\n * @api public\n */\n\nString.prototype.clone = function(){\n  var clone = new String(this.val, this.quote);\n  clone.lineno = this.lineno;\n  clone.column = this.column;\n  clone.filename = this.filename;\n  return clone;\n};\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nString.prototype.toJSON = function(){\n  return {\n    __type: 'String',\n    val: this.val,\n    quote: this.quote,\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename\n  };\n};\n\n/**\n * Return Boolean based on the length of this string.\n *\n * @return {Boolean}\n * @api public\n */\n\nString.prototype.toBoolean = function(){\n  return nodes.Boolean(this.val.length);\n};\n\n/**\n * Coerce `other` to a string.\n *\n * @param {Node} other\n * @return {String}\n * @api public\n */\n\nString.prototype.coerce = function(other){\n  switch (other.nodeName) {\n    case 'string':\n      return other;\n    case 'expression':\n      return new String(other.nodes.map(function(node){\n        return this.coerce(node).val;\n      }, this).join(' '));\n    default:\n      return new String(other.toString());\n  }\n};\n\n/**\n * Operate on `right` with the given `op`.\n *\n * @param {String} op\n * @param {Node} right\n * @return {Node}\n * @api public\n */\n\nString.prototype.operate = function(op, right){\n  switch (op) {\n    case '%':\n      var expr = new nodes.Expression;\n      expr.push(this);\n\n      // constructargs\n      var args = 'expression' == right.nodeName\n        ? utils.unwrap(right).nodes\n        : [right];\n\n      // apply\n      return sprintf.apply(null, [expr].concat(args));\n    case '+':\n      var expr = new nodes.Expression;\n      expr.push(new String(this.val + this.coerce(right).val));\n      return expr;\n    default:\n      return Node.prototype.operate.call(this, op, right);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/hsla.js":"\n/*!\n * Stylus - HSLA\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node')\n  , nodes = require('./');\n\n/**\n * Initialize a new `HSLA` with the given h,s,l,a component values.\n *\n * @param {Number} h\n * @param {Number} s\n * @param {Number} l\n * @param {Number} a\n * @api public\n */\n\nvar HSLA = exports = module.exports = function HSLA(h,s,l,a){\n  Node.call(this);\n  this.h = clampDegrees(h);\n  this.s = clampPercentage(s);\n  this.l = clampPercentage(l);\n  this.a = clampAlpha(a);\n  this.hsla = this;\n};\n\n/**\n * Inherit from `Node.prototype`.\n */\n\nHSLA.prototype.__proto__ = Node.prototype;\n\n/**\n * Return hsla(n,n,n,n).\n *\n * @return {String}\n * @api public\n */\n\nHSLA.prototype.toString = function(){\n  return 'hsla('\n    + this.h + ','\n    + this.s.toFixed(0) + '%,'\n    + this.l.toFixed(0) + '%,'\n    + this.a + ')';\n};\n\n/**\n * Return a clone of this node.\n * \n * @return {Node}\n * @api public\n */\n\nHSLA.prototype.clone = function(parent){\n  var clone = new HSLA(\n      this.h\n    , this.s\n    , this.l\n    , this.a);\n  clone.lineno = this.lineno;\n  clone.column = this.column;\n  clone.filename = this.filename;\n  return clone;\n};\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nHSLA.prototype.toJSON = function(){\n  return {\n    __type: 'HSLA',\n    h: this.h,\n    s: this.s,\n    l: this.l,\n    a: this.a,\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename\n  };\n};\n\n/**\n * Return rgba `RGBA` representation.\n *\n * @return {RGBA}\n * @api public\n */\n\nHSLA.prototype.__defineGetter__('rgba', function(){\n  return nodes.RGBA.fromHSLA(this);\n});\n\n/**\n * Return hash.\n *\n * @return {String}\n * @api public\n */\n\nHSLA.prototype.__defineGetter__('hash', function(){\n  return this.rgba.toString();\n});\n\n/**\n * Add h,s,l to the current component values.\n *\n * @param {Number} h\n * @param {Number} s\n * @param {Number} l\n * @return {HSLA} new node\n * @api public\n */\n\nHSLA.prototype.add = function(h,s,l){\n  return new HSLA(\n      this.h + h\n    , this.s + s\n    , this.l + l\n    , this.a);\n};\n\n/**\n * Subtract h,s,l from the current component values.\n *\n * @param {Number} h\n * @param {Number} s\n * @param {Number} l\n * @return {HSLA} new node\n * @api public\n */\n\nHSLA.prototype.sub = function(h,s,l){\n  return this.add(-h, -s, -l);\n};\n\n/**\n * Operate on `right` with the given `op`.\n *\n * @param {String} op\n * @param {Node} right\n * @return {Node}\n * @api public\n */\n\nHSLA.prototype.operate = function(op, right){\n  switch (op) {\n    case '==':\n    case '!=':\n    case '<=':\n    case '>=':\n    case '<':\n    case '>':\n    case 'is a':\n    case '||':\n    case '&&':\n      return this.rgba.operate(op, right);\n    default:\n      return this.rgba.operate(op, right).hsla;\n  }\n};\n\n/**\n * Return `HSLA` representation of the given `color`.\n *\n * @param {RGBA} color\n * @return {HSLA}\n * @api public\n */\n\nexports.fromRGBA = function(rgba){\n  var r = rgba.r / 255\n    , g = rgba.g / 255\n    , b = rgba.b / 255\n    , a = rgba.a;\n\n  var min = Math.min(r,g,b)\n    , max = Math.max(r,g,b)\n    , l = (max + min) / 2\n    , d = max - min\n    , h, s;\n\n  switch (max) {\n    case min: h = 0; break;\n    case r: h = 60 * (g-b) / d; break;\n    case g: h = 60 * (b-r) / d + 120; break;\n    case b: h = 60 * (r-g) / d + 240; break;\n  }\n\n  if (max == min) {\n    s = 0;\n  } else if (l < .5) {\n    s = d / (2 * l);\n  } else {\n    s = d / (2 - 2 * l);\n  }\n\n  h %= 360;\n  s *= 100;\n  l *= 100;\n\n  return new HSLA(h,s,l,a);\n};\n\n/**\n * Adjust lightness by `percent`.\n *\n * @param {Number} percent\n * @return {HSLA} for chaining\n * @api public\n */\n\nHSLA.prototype.adjustLightness = function(percent){\n  this.l = clampPercentage(this.l + this.l * (percent / 100));\n  return this;\n};\n\n/**\n * Adjust hue by `deg`.\n *\n * @param {Number} deg\n * @return {HSLA} for chaining\n * @api public\n */\n\nHSLA.prototype.adjustHue = function(deg){\n  this.h = clampDegrees(this.h + deg);\n  return this;\n};\n\n/**\n * Clamp degree `n` >= 0 and <= 360.\n *\n * @param {Number} n\n * @return {Number}\n * @api private\n */\n\nfunction clampDegrees(n) {\n  n = n % 360;\n  return n >= 0 ? n : 360 + n;\n}\n\n/**\n * Clamp percentage `n` >= 0 and <= 100.\n *\n * @param {Number} n\n * @return {Number}\n * @api private\n */\n\nfunction clampPercentage(n) {\n  return Math.max(0, Math.min(n, 100));\n}\n\n/**\n * Clamp alpha `n` >= 0 and <= 1.\n *\n * @param {Number} n\n * @return {Number}\n * @api private\n */\n\nfunction clampAlpha(n) {\n  return Math.max(0, Math.min(n, 1));\n}\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/rgba.js":"\n/*!\n * Stylus - RGBA\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node')\n  , HSLA = require('./hsla')\n  , functions = require('../functions')\n  , adjust = functions.adjust\n  , nodes = require('./');\n\n/**\n * Initialize a new `RGBA` with the given r,g,b,a component values.\n *\n * @param {Number} r\n * @param {Number} g\n * @param {Number} b\n * @param {Number} a\n * @api public\n */\n\nvar RGBA = exports = module.exports = function RGBA(r,g,b,a){\n  Node.call(this);\n  this.r = clamp(r);\n  this.g = clamp(g);\n  this.b = clamp(b);\n  this.a = clampAlpha(a);\n  this.name = '';\n  this.rgba = this;\n};\n\n/**\n * Inherit from `Node.prototype`.\n */\n\nRGBA.prototype.__proto__ = Node.prototype;\n\n/**\n * Return an `RGBA` without clamping values.\n * \n * @param {Number} r\n * @param {Number} g\n * @param {Number} b\n * @param {Number} a\n * @return {RGBA}\n * @api public\n */\n\nRGBA.withoutClamping = function(r,g,b,a){\n  var rgba = new RGBA(0,0,0,0);\n  rgba.r = r;\n  rgba.g = g;\n  rgba.b = b;\n  rgba.a = a;\n  return rgba;\n};\n\n/**\n * Return a clone of this node.\n * \n * @return {Node}\n * @api public\n */\n\nRGBA.prototype.clone = function(){\n  var clone = new RGBA(\n      this.r\n    , this.g\n    , this.b\n    , this.a);\n  clone.raw = this.raw;\n  clone.name = this.name;\n  clone.lineno = this.lineno;\n  clone.column = this.column;\n  clone.filename = this.filename;\n  return clone;\n};\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nRGBA.prototype.toJSON = function(){\n  return {\n    __type: 'RGBA',\n    r: this.r,\n    g: this.g,\n    b: this.b,\n    a: this.a,\n    raw: this.raw,\n    name: this.name,\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename\n  };\n};\n\n/**\n * Return true.\n *\n * @return {Boolean}\n * @api public\n */\n\nRGBA.prototype.toBoolean = function(){\n  return nodes.true;\n};\n\n/**\n * Return `HSLA` representation.\n *\n * @return {HSLA}\n * @api public\n */\n\nRGBA.prototype.__defineGetter__('hsla', function(){\n  return HSLA.fromRGBA(this);\n});\n\n/**\n * Return hash.\n *\n * @return {String}\n * @api public\n */\n\nRGBA.prototype.__defineGetter__('hash', function(){\n  return this.toString();\n});\n\n/**\n * Add r,g,b,a to the current component values.\n *\n * @param {Number} r\n * @param {Number} g\n * @param {Number} b\n * @param {Number} a\n * @return {RGBA} new node\n * @api public\n */\n\nRGBA.prototype.add = function(r,g,b,a){\n  return new RGBA(\n      this.r + r\n    , this.g + g\n    , this.b + b\n    , this.a + a);\n};\n\n/**\n * Subtract r,g,b,a from the current component values.\n *\n * @param {Number} r\n * @param {Number} g\n * @param {Number} b\n * @param {Number} a\n * @return {RGBA} new node\n * @api public\n */\n\nRGBA.prototype.sub = function(r,g,b,a){\n  return new RGBA(\n      this.r - r\n    , this.g - g\n    , this.b - b\n    , a == 1 ? this.a : this.a - a);\n};\n\n/**\n * Multiply rgb components by `n`.\n *\n * @param {String} n\n * @return {RGBA} new node\n * @api public\n */\n\nRGBA.prototype.multiply = function(n){\n  return new RGBA(\n      this.r * n\n    , this.g * n\n    , this.b * n\n    , this.a); \n};\n\n/**\n * Divide rgb components by `n`.\n *\n * @param {String} n\n * @return {RGBA} new node\n * @api public\n */\n\nRGBA.prototype.divide = function(n){\n  return new RGBA(\n      this.r / n\n    , this.g / n\n    , this.b / n\n    , this.a); \n};\n\n/**\n * Operate on `right` with the given `op`.\n *\n * @param {String} op\n * @param {Node} right\n * @return {Node}\n * @api public\n */\n\nRGBA.prototype.operate = function(op, right){\n  if ('in' != op) right = right.first\n\n  switch (op) {\n    case 'is a':\n      if ('string' == right.nodeName && 'color' == right.string) {\n        return nodes.true;\n      }\n      break;\n    case '+':\n      switch (right.nodeName) {\n        case 'unit':\n          var n = right.val;\n          switch (right.type) {\n            case '%': return adjust(this, new nodes.String('lightness'), right);\n            case 'deg': return this.hsla.adjustHue(n).rgba;\n            default: return this.add(n,n,n,0);\n          }\n        case 'rgba':\n          return this.add(right.r, right.g, right.b, right.a);\n        case 'hsla':\n          return this.hsla.add(right.h, right.s, right.l);\n      }\n      break;\n    case '-':\n      switch (right.nodeName) {\n        case 'unit':\n          var n = right.val;\n          switch (right.type) {\n            case '%': return adjust(this, new nodes.String('lightness'), new nodes.Unit(-n, '%'));\n            case 'deg': return this.hsla.adjustHue(-n).rgba;\n            default: return this.sub(n,n,n,0);\n          }\n        case 'rgba':\n          return this.sub(right.r, right.g, right.b, right.a);\n        case 'hsla':\n          return this.hsla.sub(right.h, right.s, right.l);\n      }\n      break;\n    case '*':\n      switch (right.nodeName) {\n        case 'unit':\n          return this.multiply(right.val);\n      }\n      break;\n    case '/':\n      switch (right.nodeName) {\n        case 'unit':\n          return this.divide(right.val);\n      }\n      break;\n  }\n  return Node.prototype.operate.call(this, op, right);\n};\n\n/**\n * Return #nnnnnn, #nnn, or rgba(n,n,n,n) string representation of the color.\n *\n * @return {String}\n * @api public\n */\n\nRGBA.prototype.toString = function(){\n  function pad(n) {\n    return n < 16\n      ? '0' + n.toString(16)\n      : n.toString(16);\n  }\n\n  // special case for transparent named color\n  if ('transparent' == this.name)\n    return this.name;\n\n  if (1 == this.a) {\n    var r = pad(this.r)\n      , g = pad(this.g)\n      , b = pad(this.b);\n\n    // Compress\n    if (r[0] == r[1] && g[0] == g[1] && b[0] == b[1]) {\n      return '#' + r[0] + g[0] + b[0];\n    } else {\n      return '#' + r + g + b;\n    }\n  } else {\n    return 'rgba('\n      + this.r + ','\n      + this.g + ','\n      + this.b + ','\n      + (+this.a.toFixed(3)) + ')';\n  }\n};\n\n/**\n * Return a `RGBA` from the given `hsla`.\n *\n * @param {HSLA} hsla\n * @return {RGBA}\n * @api public\n */\n\nexports.fromHSLA = function(hsla){\n  var h = hsla.h / 360\n    , s = hsla.s / 100\n    , l = hsla.l / 100\n    , a = hsla.a;\n\n  var m2 = l <= .5 ? l * (s + 1) : l + s - l * s\n    , m1 = l * 2 - m2;\n\n  var r = hue(h + 1/3) * 0xff\n    , g = hue(h) * 0xff\n    , b = hue(h - 1/3) * 0xff;\n\n  function hue(h) {\n    if (h < 0) ++h;\n    if (h > 1) --h;\n    if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;\n    if (h * 2 < 1) return m2;\n    if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;\n    return m1;\n  }\n  \n  return new RGBA(r,g,b,a);\n};\n\n/**\n * Clamp `n` >= 0 and <= 255.\n *\n * @param {Number} n\n * @return {Number}\n * @api private\n */\n\nfunction clamp(n) {\n  return Math.max(0, Math.min(n.toFixed(0), 255));\n}\n\n/**\n * Clamp alpha `n` >= 0 and <= 1.\n *\n * @param {Number} n\n * @return {Number}\n * @api private\n */\n\nfunction clampAlpha(n) {\n  return Math.max(0, Math.min(n, 1));\n}\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/ident.js":"\n/*!\n * Stylus - Ident\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node')\n  , nodes = require('./');\n\n/**\n * Initialize a new `Ident` by `name` with the given `val` node.\n *\n * @param {String} name\n * @param {Node} val\n * @api public\n */\n\nvar Ident = module.exports = function Ident(name, val, mixin){\n  Node.call(this);\n  this.name = name;\n  this.string = name;\n  this.val = val || nodes.null;\n  this.mixin = !!mixin;\n};\n\n/**\n * Check if the variable has a value.\n *\n * @return {Boolean}\n * @api public\n */\n\nIdent.prototype.__defineGetter__('isEmpty', function(){\n  return undefined == this.val;\n});\n\n/**\n * Return hash.\n *\n * @return {String}\n * @api public\n */\n\nIdent.prototype.__defineGetter__('hash', function(){\n  return this.name;\n});\n\n/**\n * Inherit from `Node.prototype`.\n */\n\nIdent.prototype.__proto__ = Node.prototype;\n\n/**\n * Return a clone of this node.\n * \n * @return {Node}\n * @api public\n */\n\nIdent.prototype.clone = function(parent){\n  var clone = new Ident(this.name);\n  clone.val = this.val.clone(parent, clone);\n  clone.mixin = this.mixin;\n  clone.lineno = this.lineno;\n  clone.column = this.column;\n  clone.filename = this.filename;\n  clone.property = this.property;\n  clone.rest = this.rest;\n  return clone;\n};\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nIdent.prototype.toJSON = function(){\n  return {\n    __type: 'Ident',\n    name: this.name,\n    val: this.val,\n    mixin: this.mixin,\n    property: this.property,\n    rest: this.rest,\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename\n  };\n};\n\n/**\n * Return <name>.\n *\n * @return {String}\n * @api public\n */\n\nIdent.prototype.toString = function(){\n  return this.name;\n};\n\n/**\n * Coerce `other` to an ident.\n *\n * @param {Node} other\n * @return {String}\n * @api public\n */\n\nIdent.prototype.coerce = function(other){\n  switch (other.nodeName) {\n    case 'ident':\n    case 'string':\n    case 'literal':\n      return new Ident(other.string);\n    case 'unit':\n      return new Ident(other.toString());\n    default:\n      return Node.prototype.coerce.call(this, other);\n  }\n};\n\n/**\n * Operate on `right` with the given `op`.\n *\n * @param {String} op\n * @param {Node} right\n * @return {Node}\n * @api public\n */\n\nIdent.prototype.operate = function(op, right){\n  var val = right.first;\n  switch (op) {\n    case '-':\n      if ('unit' == val.nodeName) {\n        var expr = new nodes.Expression;\n        val = val.clone();\n        val.val = -val.val;\n        expr.push(this);\n        expr.push(val);\n        return expr;\n      }\n    case '+':\n      return new nodes.Ident(this.string + this.coerce(val).string);\n  }\n  return Node.prototype.operate.call(this, op, right);\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/group.js":"\n/*!\n * Stylus - Group\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a new `Group`.\n *\n * @api public\n */\n\nvar Group = module.exports = function Group(){\n  Node.call(this);\n  this.nodes = [];\n  this.extends = [];\n};\n\n/**\n * Inherit from `Node.prototype`.\n */\n\nGroup.prototype.__proto__ = Node.prototype;\n\n/**\n * Push the given `selector` node.\n *\n * @param {Selector} selector\n * @api public\n */\n\nGroup.prototype.push = function(selector){\n  this.nodes.push(selector);\n};\n\n/**\n * Return this set's `Block`.\n */\n\nGroup.prototype.__defineGetter__('block', function(){\n  return this.nodes[0].block;\n});\n\n/**\n * Assign `block` to each selector in this set.\n *\n * @param {Block} block\n * @api public\n */\n\nGroup.prototype.__defineSetter__('block', function(block){\n  for (var i = 0, len = this.nodes.length; i < len; ++i) {\n    this.nodes[i].block = block;\n  }\n});\n\n/**\n * Check if this set has only placeholders.\n *\n * @return {Boolean}\n * @api public\n */\n\nGroup.prototype.__defineGetter__('hasOnlyPlaceholders', function(){\n  return this.nodes.every(function(selector) { return selector.isPlaceholder; });\n});\n\n/**\n * Return a clone of this node.\n * \n * @return {Node}\n * @api public\n */\n\nGroup.prototype.clone = function(parent){\n  var clone = new Group;\n  clone.lineno = this.lineno;\n  clone.column = this.column;\n  this.nodes.forEach(function(node){\n    clone.push(node.clone(parent, clone));\n  });\n  clone.filename = this.filename;\n  clone.block = this.block.clone(parent, clone);\n  return clone;\n};\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nGroup.prototype.toJSON = function(){\n  return {\n    __type: 'Group',\n    nodes: this.nodes,\n    block: this.block,\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/literal.js":"\n/*!\n * Stylus - Literal\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node')\n  , nodes = require('./');\n\n/**\n * Initialize a new `Literal` with the given `str`.\n *\n * @param {String} str\n * @api public\n */\n\nvar Literal = module.exports = function Literal(str){\n  Node.call(this);\n  this.val = str;\n  this.string = str;\n  this.prefixed = false;\n};\n\n/**\n * Inherit from `Node.prototype`.\n */\n\nLiteral.prototype.__proto__ = Node.prototype;\n\n/**\n * Return hash.\n *\n * @return {String}\n * @api public\n */\n\nLiteral.prototype.__defineGetter__('hash', function(){\n  return this.val;\n});\n\n/**\n * Return literal value.\n *\n * @return {String}\n * @api public\n */\n\nLiteral.prototype.toString = function(){\n  return this.val;\n};\n\n/**\n * Coerce `other` to a literal.\n *\n * @param {Node} other\n * @return {String}\n * @api public\n */\n\nLiteral.prototype.coerce = function(other){\n  switch (other.nodeName) {\n    case 'ident':\n    case 'string':\n    case 'literal':\n      return new Literal(other.string);\n    default:\n      return Node.prototype.coerce.call(this, other);\n  }\n};\n\n/**\n * Operate on `right` with the given `op`.\n *\n * @param {String} op\n * @param {Node} right\n * @return {Node}\n * @api public\n */\n\nLiteral.prototype.operate = function(op, right){\n  var val = right.first;\n  switch (op) {\n    case '+':\n      return new nodes.Literal(this.string + this.coerce(val).string);\n    default:\n      return Node.prototype.operate.call(this, op, right);\n  }\n};\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nLiteral.prototype.toJSON = function(){\n  return {\n    __type: 'Literal',\n    val: this.val,\n    string: this.string,\n    prefixed: this.prefixed,\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/boolean.js":"\n/*!\n * Stylus - Boolean\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node')\n  , nodes = require('./');\n\n/**\n * Initialize a new `Boolean` node with the given `val`.\n *\n * @param {Boolean} val\n * @api public\n */\n\nvar Boolean = module.exports = function Boolean(val){\n  Node.call(this);\n  if (this.nodeName) {\n    this.val = !!val;\n  } else {\n    return new Boolean(val);\n  }\n};\n\n/**\n * Inherit from `Node.prototype`.\n */\n\nBoolean.prototype.__proto__ = Node.prototype;\n\n/**\n * Return `this` node.\n *\n * @return {Boolean}\n * @api public\n */\n\nBoolean.prototype.toBoolean = function(){\n  return this;\n};\n\n/**\n * Return `true` if this node represents `true`.\n *\n * @return {Boolean}\n * @api public\n */\n\nBoolean.prototype.__defineGetter__('isTrue', function(){\n  return this.val;\n});\n\n/**\n * Return `true` if this node represents `false`.\n *\n * @return {Boolean}\n * @api public\n */\n\nBoolean.prototype.__defineGetter__('isFalse', function(){\n  return ! this.val;\n});\n\n/**\n * Negate the value.\n *\n * @return {Boolean}\n * @api public\n */\n\nBoolean.prototype.negate = function(){\n  return new Boolean(!this.val);\n};\n\n/**\n * Return 'Boolean'.\n *\n * @return {String}\n * @api public\n */\n\nBoolean.prototype.inspect = function(){\n  return '[Boolean ' + this.val + ']';\n};\n\n/**\n * Return 'true' or 'false'.\n *\n * @return {String}\n * @api public\n */\n\nBoolean.prototype.toString = function(){\n  return this.val\n    ? 'true'\n    : 'false';\n};\n\n/**\n * Return a JSON representaiton of this node.\n *\n * @return {Object}\n * @api public\n */\n\nBoolean.prototype.toJSON = function(){\n  return {\n    __type: 'Boolean',\n    val: this.val\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/return.js":"\n/*!\n * Stylus - Return\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node')\n  , nodes = require('./');\n\n/**\n * Initialize a new `Return` node with the given `expr`.\n *\n * @param {Expression} expr\n * @api public\n */\n\nvar Return = module.exports = function Return(expr){\n  this.expr = expr || nodes.null;\n};\n\n/**\n * Inherit from `Node.prototype`.\n */\n\nReturn.prototype.__proto__ = Node.prototype;\n\n/**\n * Return a clone of this node.\n * \n * @return {Node}\n * @api public\n */\n\nReturn.prototype.clone = function(parent){\n  var clone = new Return();\n  clone.expr = this.expr.clone(parent, clone);\n  clone.lineno = this.lineno;\n  clone.column = this.column;\n  clone.filename = this.filename;\n  return clone;\n};\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nReturn.prototype.toJSON = function(){\n  return {\n    __type: 'Return',\n    expr: this.expr,\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/media.js":"\n/*!\n * Stylus - Media\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Atrule = require('./atrule');\n\n/**\n * Initialize a new `Media` with the given `val`\n *\n * @param {String} val\n * @api public\n */\n\nvar Media = module.exports = function Media(val){\n  Atrule.call(this, 'media');\n  this.val = val;\n};\n\n/**\n * Inherit from `Atrule.prototype`.\n */\n\nMedia.prototype.__proto__ = Atrule.prototype;\n\n/**\n * Clone this node.\n *\n * @return {Media}\n * @api public\n */\n\nMedia.prototype.clone = function(parent){\n  var clone = new Media;\n  clone.val = this.val.clone(parent, clone);\n  clone.block = this.block.clone(parent, clone);\n  clone.lineno = this.lineno;\n  clone.column = this.column;\n  clone.filename = this.filename;\n  return clone;\n};\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nMedia.prototype.toJSON = function(){\n  return {\n    __type: 'Media',\n    val: this.val,\n    block: this.block,\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename\n  };\n};\n\n/**\n * Return @media \"val\".\n *\n * @return {String}\n * @api public\n */\n\nMedia.prototype.toString = function(){\n  return '@media ' + this.val;\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/atrule.js":"/*!\n * Stylus - at-rule\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a new at-rule node.\n *\n * @param {String} type\n * @api public\n */\n\nvar Atrule = module.exports = function Atrule(type){\n  Node.call(this);\n  this.type = type;\n};\n\n/**\n * Inherit from `Node.prototype`.\n */\n\nAtrule.prototype.__proto__ = Node.prototype;\n\n/**\n * Check if at-rule's block has only properties.\n *\n * @return {Boolean}\n * @api public\n */\n\nAtrule.prototype.__defineGetter__('hasOnlyProperties', function(){\n  if (!this.block) return false;\n\n  var nodes = this.block.nodes;\n  for (var i = 0, len = nodes.length; i < len; ++i) {\n    var nodeName = nodes[i].nodeName;\n    switch(nodes[i].nodeName) {\n      case 'property':\n      case 'expression':\n      case 'comment':\n        continue;\n      default:\n        return false;\n    }\n  }\n  return true;\n});\n\n/**\n * Return a clone of this node.\n *\n * @return {Node}\n * @api public\n */\n\nAtrule.prototype.clone = function(parent){\n  var clone = new Atrule(this.type);\n  if (this.block) clone.block = this.block.clone(parent, clone);\n  clone.segments = this.segments.map(function(node){ return node.clone(parent, clone); });\n  clone.lineno = this.lineno;\n  clone.column = this.column;\n  clone.filename = this.filename;\n  return clone;\n};\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nAtrule.prototype.toJSON = function(){\n  var json = {\n    __type: 'Atrule',\n    type: this.type,\n    segments: this.segments,\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename\n  };\n  if (this.block) json.block = this.block;\n  return json;\n};\n\n/**\n * Return @<type>.\n *\n * @return {String}\n * @api public\n */\n\nAtrule.prototype.toString = function(){\n  return '@' + this.type;\n};\n\n/**\n * Check if the at-rule's block has output nodes.\n *\n * @return {Boolean}\n * @api public\n */\n\nAtrule.prototype.__defineGetter__('hasOutput', function(){\n  return !!this.block && hasOutput(this.block);\n});\n\nfunction hasOutput(block) {\n  var nodes = block.nodes;\n\n  // only placeholder selectors\n  if (nodes.every(function(node){\n    return 'group' == node.nodeName && node.hasOnlyPlaceholders;\n  })) return false;\n\n  // something visible\n  return nodes.some(function(node) {\n    switch (node.nodeName) {\n      case 'property':\n      case 'literal':\n      case 'import':\n        return true;\n      case 'block':\n        return hasOutput(node);\n      default:\n        if (node.block) return hasOutput(node.block);\n    }\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/query-list.js":"\n/*!\n * Stylus - QueryList\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a new `QueryList`.\n *\n * @api public\n */\n\nvar QueryList = module.exports = function QueryList(){\n  Node.call(this);\n  this.nodes = [];\n};\n\n/**\n * Inherit from `Node.prototype`.\n */\n\nQueryList.prototype.__proto__ = Node.prototype;\n\n/**\n * Return a clone of this node.\n * \n * @return {Node}\n * @api public\n */\n\nQueryList.prototype.clone = function(parent){\n  var clone = new QueryList;\n  clone.lineno = this.lineno;\n  clone.column = this.column;\n  clone.filename = this.filename;\n  for (var i = 0; i < this.nodes.length; ++i) {\n    clone.push(this.nodes[i].clone(parent, clone));\n  }\n  return clone;\n};\n\n/**\n * Push the given `node`.\n *\n * @param {Node} node\n * @api public\n */\n\nQueryList.prototype.push = function(node){\n  this.nodes.push(node);\n};\n\n/**\n * Merges this query list with the `other`.\n *\n * @param {QueryList} other\n * @return {QueryList}\n * @api private\n */\n\nQueryList.prototype.merge = function(other){\n  var list = new QueryList\n    , merged;\n  this.nodes.forEach(function(query){\n    for (var i = 0, len = other.nodes.length; i < len; ++i){\n      merged = query.merge(other.nodes[i]);\n      if (merged) list.push(merged);\n    }\n  });\n  return list;\n};\n\n/**\n * Return \"<a>, <b>, <c>\"\n *\n * @return {String}\n * @api public\n */\n\nQueryList.prototype.toString = function(){\n  return '(' + this.nodes.map(function(node){\n    return node.toString();\n  }).join(', ') + ')';\n};\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nQueryList.prototype.toJSON = function(){\n  return {\n    __type: 'QueryList',\n    nodes: this.nodes,\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/query.js":"\n/*!\n * Stylus - Query\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a new `Query`.\n *\n * @api public\n */\n\nvar Query = module.exports = function Query(){\n  Node.call(this);\n  this.nodes = [];\n  this.type = '';\n  this.predicate = '';\n};\n\n/**\n * Inherit from `Node.prototype`.\n */\n\nQuery.prototype.__proto__ = Node.prototype;\n\n/**\n * Return a clone of this node.\n * \n * @return {Node}\n * @api public\n */\n\nQuery.prototype.clone = function(parent){\n  var clone = new Query;\n  clone.predicate = this.predicate;\n  clone.type = this.type;\n  for (var i = 0, len = this.nodes.length; i < len; ++i) {\n    clone.push(this.nodes[i].clone(parent, clone));\n  }\n  clone.lineno = this.lineno;\n  clone.column = this.column;\n  clone.filename = this.filename;\n  return clone;\n};\n\n/**\n * Push the given `feature`.\n *\n * @param {Feature} feature\n * @api public\n */\n\nQuery.prototype.push = function(feature){\n  this.nodes.push(feature);\n};\n\n/**\n * Return resolved type of this query.\n *\n * @return {String}\n * @api private\n */\n\nQuery.prototype.__defineGetter__('resolvedType', function(){\n  if (this.type) {\n    return this.type.nodeName\n      ? this.type.string\n      : this.type;\n  }\n});\n\n/**\n * Return resolved predicate of this query.\n *\n * @return {String}\n * @api private\n */\n\nQuery.prototype.__defineGetter__('resolvedPredicate', function(){\n  if (this.predicate) {\n    return this.predicate.nodeName\n      ? this.predicate.string\n      : this.predicate;\n  }\n});\n\n/**\n * Merges this query with the `other`.\n *\n * @param {Query} other\n * @return {Query}\n * @api private\n */\n\nQuery.prototype.merge = function(other){\n  var query = new Query\n    , p1 = this.resolvedPredicate\n    , p2 = other.resolvedPredicate\n    , t1 = this.resolvedType\n    , t2 = other.resolvedType\n    , type, pred;\n\n  // Stolen from Sass :D\n  t1 = t1 || t2;\n  t2 = t2 || t1;\n  if (('not' == p1) ^ ('not' == p2)) {\n    if (t1 == t2) return;\n    type = ('not' == p1) ? t2 : t1;\n    pred = ('not' == p1) ? p2 : p1;\n  } else if (('not' == p1) && ('not' == p2)) {\n    if (t1 != t2) return;\n    type = t1;\n    pred = 'not';\n  } else if (t1 != t2) {\n    return;\n  } else {\n    type = t1;\n    pred = p1 || p2;\n  }\n  query.predicate = pred;\n  query.type = type;\n  query.nodes = this.nodes.concat(other.nodes);\n  return query;\n};\n\n/**\n * Return \"<a> and <b> and <c>\"\n *\n * @return {String}\n * @api public\n */\n\nQuery.prototype.toString = function(){\n  var pred = this.predicate ? this.predicate + ' ' : ''\n    , type = this.type || ''\n    , len = this.nodes.length\n    , str = pred + type;\n  if (len) {\n    str += (type && ' and ') + this.nodes.map(function(expr){\n      return expr.toString();\n    }).join(' and ');\n  }\n  return str;\n};\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nQuery.prototype.toJSON = function(){\n  return {\n    __type: 'Query',\n    predicate: this.predicate,\n    type: this.type,\n    nodes: this.nodes,\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/feature.js":"\n/*!\n * Stylus - Feature\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a new `Feature` with the given `segs`.\n *\n * @param {Array} segs\n * @api public\n */\n\nvar Feature = module.exports = function Feature(segs){\n  Node.call(this);\n  this.segments = segs;\n  this.expr = null;\n};\n\n/**\n * Inherit from `Node.prototype`.\n */\n\nFeature.prototype.__proto__ = Node.prototype;\n\n/**\n * Return a clone of this node.\n * \n * @return {Node}\n * @api public\n */\n\nFeature.prototype.clone = function(parent){\n  var clone = new Feature;\n  clone.segments = this.segments.map(function(node){ return node.clone(parent, clone); });\n  if (this.expr) clone.expr = this.expr.clone(parent, clone);\n  if (this.name) clone.name = this.name;\n  clone.lineno = this.lineno;\n  clone.column = this.column;\n  clone.filename = this.filename;\n  return clone;\n};\n\n/**\n * Return \"<ident>\" or \"(<ident>: <expr>)\"\n *\n * @return {String}\n * @api public\n */\n\nFeature.prototype.toString = function(){\n  if (this.expr) {\n    return '(' + this.segments.join('') + ': ' + this.expr.toString() + ')';\n  } else {\n    return this.segments.join('');\n  }\n};\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nFeature.prototype.toJSON = function(){\n  var json = {\n    __type: 'Feature',\n    segments: this.segments,\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename\n  };\n  if (this.expr) json.expr = this.expr;\n  if (this.name) json.name = this.name;\n  return json;\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/params.js":"\n/*!\n * Stylus - Params\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a new `Params` with `name`, `params`, and `body`.\n *\n * @param {String} name\n * @param {Params} params\n * @param {Expression} body\n * @api public\n */\n\nvar Params = module.exports = function Params(){\n  Node.call(this);\n  this.nodes = [];\n};\n\n/**\n * Check function arity.\n *\n * @return {Boolean}\n * @api public\n */\n\nParams.prototype.__defineGetter__('length', function(){\n  return this.nodes.length;\n});\n\n/**\n * Inherit from `Node.prototype`.\n */\n\nParams.prototype.__proto__ = Node.prototype;\n\n/**\n * Push the given `node`.\n *\n * @param {Node} node\n * @api public\n */\n\nParams.prototype.push = function(node){\n  this.nodes.push(node);\n};\n\n/**\n * Return a clone of this node.\n * \n * @return {Node}\n * @api public\n */\n\nParams.prototype.clone = function(parent){\n  var clone = new Params;\n  clone.lineno = this.lineno;\n  clone.column = this.column;\n  clone.filename = this.filename;\n  this.nodes.forEach(function(node){\n    clone.push(node.clone(parent, clone));\n  });\n  return clone;\n};\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nParams.prototype.toJSON = function(){\n  return {\n    __type: 'Params',\n    nodes: this.nodes,\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename\n  };\n};\n\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/comment.js":"\n/*!\n * Stylus - Comment\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a new `Comment` with the given `str`.\n *\n * @param {String} str\n * @param {Boolean} suppress\n * @param {Boolean} inline\n * @api public\n */\n\nvar Comment = module.exports = function Comment(str, suppress, inline){\n  Node.call(this);\n  this.str = str;\n  this.suppress = suppress;\n  this.inline = inline;\n};\n\n/**\n * Inherit from `Node.prototype`.\n */\n\nComment.prototype.__proto__ = Node.prototype;\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nComment.prototype.toJSON = function(){\n  return {\n    __type: 'Comment',\n    str: this.str,\n    suppress: this.suppress,\n    inline: this.inline,\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename\n  };\n};\n\n/**\n * Return comment.\n *\n * @return {String}\n * @api public\n */\n\nComment.prototype.toString = function(){\n  return this.str;\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/keyframes.js":"\n/*!\n * Stylus - Keyframes\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Atrule = require('./atrule');\n\n/**\n * Initialize a new `Keyframes` with the given `segs`,\n * and optional vendor `prefix`.\n *\n * @param {Array} segs\n * @param {String} prefix\n * @api public\n */\n\nvar Keyframes = module.exports = function Keyframes(segs, prefix){\n  Atrule.call(this, 'keyframes');\n  this.segments = segs;\n  this.prefix = prefix || 'official';\n};\n\n/**\n * Inherit from `Atrule.prototype`.\n */\n\nKeyframes.prototype.__proto__ = Atrule.prototype;\n\n/**\n * Return a clone of this node.\n * \n * @return {Node}\n * @api public\n */\n\nKeyframes.prototype.clone = function(parent){\n  var clone = new Keyframes;\n  clone.lineno = this.lineno;\n  clone.column = this.column;\n  clone.filename = this.filename;\n  clone.segments = this.segments.map(function(node) { return node.clone(parent, clone); });\n  clone.prefix = this.prefix;\n  clone.block = this.block.clone(parent, clone);\n  return clone;\n};\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nKeyframes.prototype.toJSON = function(){\n  return {\n    __type: 'Keyframes',\n    segments: this.segments,\n    prefix: this.prefix,\n    block: this.block,\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename\n  };\n};\n\n/**\n * Return `@keyframes name`.\n *\n * @return {String}\n * @api public\n */\n\nKeyframes.prototype.toString = function(){\n  return '@keyframes ' + this.segments.join('');\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/member.js":"\n/*!\n * Stylus - Member\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a new `Member` with `left` and `right`.\n *\n * @param {Node} left\n * @param {Node} right\n * @api public\n */\n\nvar Member = module.exports = function Member(left, right){\n  Node.call(this);\n  this.left = left;\n  this.right = right;\n};\n\n/**\n * Inherit from `Node.prototype`.\n */\n\nMember.prototype.__proto__ = Node.prototype;\n\n/**\n * Return a clone of this node.\n *\n * @return {Node}\n * @api public\n */\n\nMember.prototype.clone = function(parent){\n  var clone = new Member;\n  clone.left = this.left.clone(parent, clone);\n  clone.right = this.right.clone(parent, clone);\n  if (this.val) clone.val = this.val.clone(parent, clone);\n  clone.lineno = this.lineno;\n  clone.column = this.column;\n  clone.filename = this.filename;\n  return clone;\n};\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nMember.prototype.toJSON = function(){\n  var json = {\n    __type: 'Member',\n    left: this.left,\n    right: this.right,\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename\n  };\n  if (this.val) json.val = this.val;\n  return json;\n};\n\n/**\n * Return a string representation of this node.\n *\n * @return {String}\n * @api public\n */\n\nMember.prototype.toString = function(){\n  return this.left.toString()\n    + '.' + this.right.toString();\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/charset.js":"\n/*!\n * Stylus - Charset\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a new `Charset` with the given `val`\n *\n * @param {String} val\n * @api public\n */\n\nvar Charset = module.exports = function Charset(val){\n  Node.call(this);\n  this.val = val;\n};\n\n/**\n * Inherit from `Node.prototype`.\n */\n\nCharset.prototype.__proto__ = Node.prototype;\n\n/**\n * Return @charset \"val\".\n *\n * @return {String}\n * @api public\n */\n\nCharset.prototype.toString = function(){\n  return '@charset ' + this.val;\n};\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nCharset.prototype.toJSON = function(){\n  return {\n    __type: 'Charset',\n    val: this.val,\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/namespace.js":"/*!\n * Stylus - Namespace\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a new `Namespace` with the given `val` and `prefix`\n *\n * @param {String|Call} val\n * @param {String} [prefix]\n * @api public\n */\n\nvar Namespace = module.exports = function Namespace(val, prefix){\n  Node.call(this);\n  this.val = val;\n  this.prefix = prefix;\n};\n\n/**\n * Inherit from `Node.prototype`.\n */\n\nNamespace.prototype.__proto__ = Node.prototype;\n\n/**\n * Return @namespace \"val\".\n *\n * @return {String}\n * @api public\n */\n\nNamespace.prototype.toString = function(){\n  return '@namespace ' + (this.prefix ? this.prefix + ' ' : '') + this.val;\n};\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nNamespace.prototype.toJSON = function(){\n  return {\n    __type: 'Namespace',\n    val: this.val,\n    prefix: this.prefix,\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/import.js":"\n/*!\n * Stylus - Import\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a new `Import` with the given `expr`.\n *\n * @param {Expression} expr\n * @api public\n */\n\nvar Import = module.exports = function Import(expr, once){\n  Node.call(this);\n  this.path = expr;\n  this.once = once || false;\n};\n\n/**\n * Inherit from `Node.prototype`.\n */\n\nImport.prototype.__proto__ = Node.prototype;\n\n/**\n * Return a clone of this node.\n *\n * @return {Node}\n * @api public\n */\n\nImport.prototype.clone = function(parent){\n  var clone = new Import();\n  clone.path = this.path.nodeName ? this.path.clone(parent, clone) : this.path;\n  clone.once = this.once;\n  clone.mtime = this.mtime;\n  clone.lineno = this.lineno;\n  clone.column = this.column;\n  clone.filename = this.filename;\n  return clone;\n};\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nImport.prototype.toJSON = function(){\n  return {\n    __type: 'Import',\n    path: this.path,\n    once: this.once,\n    mtime: this.mtime,\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/extend.js":"\n/*!\n * Stylus - Extend\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a new `Extend` with the given `selectors` array.\n *\n * @param {Array} selectors array of the selectors\n * @api public\n */\n\nvar Extend = module.exports = function Extend(selectors){\n  Node.call(this);\n  this.selectors = selectors;\n};\n\n/**\n * Inherit from `Node.prototype`.\n */\n\nExtend.prototype.__proto__ = Node.prototype;\n\n/**\n * Return a clone of this node.\n * \n * @return {Node}\n * @api public\n */\n\nExtend.prototype.clone = function(){\n  return new Extend(this.selectors);\n};\n\n/**\n * Return `@extend selectors`.\n *\n * @return {String}\n * @api public\n */\n\nExtend.prototype.toString = function(){\n  return '@extend ' + this.selectors.join(', ');\n};\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nExtend.prototype.toJSON = function(){\n  return {\n    __type: 'Extend',\n    selectors: this.selectors,\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/object.js":"\n/*!\n * Stylus - Object\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node')\n  , nodes = require('./')\n  , nativeObj = {}.constructor;\n\n/**\n * Initialize a new `Object`.\n *\n * @api public\n */\n\nvar Object = module.exports = function Object(){\n  Node.call(this);\n  this.vals = {};\n};\n\n/**\n * Inherit from `Node.prototype`.\n */\n\nObject.prototype.__proto__ = Node.prototype;\n\n/**\n * Set `key` to `val`.\n *\n * @param {String} key\n * @param {Node} val\n * @return {Object} for chaining\n * @api public\n */\n\nObject.prototype.set = function(key, val){\n  this.vals[key] = val;\n  return this;\n};\n\n/**\n * Return length.\n *\n * @return {Number}\n * @api public\n */\n\nObject.prototype.__defineGetter__('length', function() {\n  return nativeObj.keys(this.vals).length;\n});\n\n/**\n * Get `key`.\n *\n * @param {String} key\n * @return {Node}\n * @api public\n */\n\nObject.prototype.get = function(key){\n  return this.vals[key] || nodes.null;\n};\n\n/**\n * Has `key`?\n *\n * @param {String} key\n * @return {Boolean}\n * @api public\n */\n\nObject.prototype.has = function(key){\n  return key in this.vals;\n};\n\n/**\n * Operate on `right` with the given `op`.\n *\n * @param {String} op\n * @param {Node} right\n * @return {Node}\n * @api public\n */\n\nObject.prototype.operate = function(op, right){\n  switch (op) {\n    case '.':\n    case '[]':\n      return this.get(right.hash);\n    case '==':\n      var vals = this.vals\n        , a\n        , b;\n      if ('object' != right.nodeName || this.length != right.length)\n        return nodes.false;\n      for (var key in vals) {\n        a = vals[key];\n        b = right.vals[key];\n        if (a.operate(op, b).isFalse)\n          return nodes.false;\n      }\n      return nodes.true;\n    case '!=':\n      return this.operate('==', right).negate();\n    default:\n      return Node.prototype.operate.call(this, op, right);\n  }\n};\n\n/**\n * Return Boolean based on the length of this object.\n *\n * @return {Boolean}\n * @api public\n */\n\nObject.prototype.toBoolean = function(){\n  return nodes.Boolean(this.length);\n};\n\n/**\n * Convert object to string with properties.\n *\n * @return {String}\n * @api private\n */\n\nObject.prototype.toBlock = function(){\n  var str = '{'\n    , key\n    , val;\n  for (key in this.vals) {\n    val = this.get(key);\n    if ('object' == val.first.nodeName) {\n      str += key + ' ' + val.first.toBlock();\n    } else {\n      switch (key) {\n        case '@charset':\n          str += key + ' ' + val.first.toString() + ';';\n          break;\n        default:\n          str += key + ':' + toString(val) + ';';\n      }\n    }\n  }\n  str += '}';\n  return str;\n\n  function toString(node) {\n    if (node.nodes) {\n      return node.nodes.map(toString).join(node.isList ? ',' : ' ');\n    } else if ('literal' == node.nodeName && ',' == node.val) {\n      return '\\\\,';\n    }\n    return node.toString();\n  }\n};\n\n/**\n * Return a clone of this node.\n * \n * @return {Node}\n * @api public\n */\n\nObject.prototype.clone = function(parent){\n  var clone = new Object;\n  clone.lineno = this.lineno;\n  clone.column = this.column;\n  clone.filename = this.filename;\n  for (var key in this.vals) {\n    clone.vals[key] = this.vals[key].clone(parent, clone);\n  }\n  return clone;\n};\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nObject.prototype.toJSON = function(){\n  return {\n    __type: 'Object',\n    vals: this.vals,\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename\n  };\n};\n\n/**\n * Return \"{ <prop>: <val> }\"\n *\n * @return {String}\n * @api public\n */\n\nObject.prototype.toString = function(){\n  var obj = {};\n  for (var prop in this.vals) {\n    obj[prop] = this.vals[prop].toString();\n  }\n  return JSON.stringify(obj);\n};\n","/home/travis/build/npmtest/node-npmtest-stylus/stylus/lib/nodes/function.js":"\n/*!\n * Stylus - Function\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a new `Function` with `name`, `params`, and `body`.\n *\n * @param {String} name\n * @param {Params|Function} params\n * @param {Block} body\n * @api public\n */\n\nvar Function = module.exports = function Function(name, params, body){\n  Node.call(this);\n  this.name = name;\n  this.params = params;\n  this.block = body;\n  if ('function' == typeof params) this.fn = params;\n};\n\n/**\n * Check function arity.\n *\n * @return {Boolean}\n * @api public\n */\n\nFunction.prototype.__defineGetter__('arity', function(){\n  return this.params.length;\n});\n\n/**\n * Inherit from `Node.prototype`.\n */\n\nFunction.prototype.__proto__ = Node.prototype;\n\n/**\n * Return hash.\n *\n * @return {String}\n * @api public\n */\n\nFunction.prototype.__defineGetter__('hash', function(){\n  return 'function ' + this.name;\n});\n\n/**\n * Return a clone of this node.\n * \n * @return {Node}\n * @api public\n */\n\nFunction.prototype.clone = function(parent){\n  if (this.fn) {\n    var clone = new Function(\n        this.name\n      , this.fn);\n  } else {\n    var clone = new Function(this.name);\n    clone.params = this.params.clone(parent, clone);\n    clone.block = this.block.clone(parent, clone);\n  }\n  clone.lineno = this.lineno;\n  clone.column = this.column;\n  clone.filename = this.filename;\n  return clone;\n};\n\n/**\n * Return <name>(param1, param2, ...).\n *\n * @return {String}\n * @api public\n */\n\nFunction.prototype.toString = function(){\n  if (this.fn) {\n    return this.name\n      + '('\n      + this.fn.toString()\n        .match(/^function *\\w*\\((.*?)\\)/)\n        .slice(1)\n        .join(', ')\n      + ')';\n  } else {\n    return this.name\n      + '('\n      + this.params.nodes.join(', ')\n      + ')';\n  }\n};\n\n/**\n * Return a JSON representation of this node.\n *\n * @return {Object}\n * @api public\n */\n\nFunction.prototype.toJSON = function(){\n  var json = {\n    __type: 'Function',\n    name: this.name,\n    lineno: this.lineno,\n    column: this.column,\n    filename: this.filename\n  };\n  if (this.fn) {\n    json.fn = this.fn;\n  } else {\n    json.params = this.params;\n    json.block = this.block;\n  }\n  return json;\n};\n"}